// LoadDriver.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "Tlhelp32.h"


#define FILE_DEVICE_UNKNOWN             0x00000022
#define IOCTL_UNKNOWN_BASE              FILE_DEVICE_UNKNOWN

#define IOCTL_PROCVIEW_GET_PROCINFO     CTL_CODE(IOCTL_UNKNOWN_BASE, 0x0800, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)


const TCHAR* OTHER_FILE_NAME = _T("D:\\Test.txt"); //same value as on dllmain OTHER_FILE_NAME



TCHAR* SANDBOXIE_DLL_PATH = _T("C:\\Program Files\\Sandboxie\\SbieDll.dll");
TCHAR* SANDBOXIE_PATH = _T("C:\\Program Files\\Sandboxie");

#ifdef _DEBUG
TCHAR* ORIGIN_PATH = _T("D:\\LoadDriverDebugProcess\\Debug\\");
//char* dllPath = "D:\\LoadDriverDebugProcess\\Debug\\SbieDll.dll";
char* EMPTY_PATH = "D:\\LoadDriverDebugProcess\\Debug\\empty.exe";
char* PROCESS_PATH ="D:\\LoadDriverDebugProcess\\Debug\\%s";
#else
TCHAR* ORIGIN_PATH = _T("D:\\LoadDriverDebugProcess\\Release\\");
//char* dllPath = "D:\\LoadDriverDebugProcess\\Release\\SbieDll.dll";
char* EMPTY_PATH = "D:\\LoadDriverDebugProcess\\Release\\empty.exe";
char* PROCESS_PATH ="D:\\LoadDriverDebugProcess\\Release\\%s"; 
#endif

#define NOSBIE 20

enum {
	FAIL	= -1,
	ALL_SB	=  0,
	VMWARE	=  1,
	VBOX	=  2,
	BOCHS	=  3,
	QEMU	=  4,
	WINE	=  5
};

typedef struct _CallbackInfo
{
    HANDLE  hProcessId;
    PVOID   loadLibraryAddress;
}CALLBACK_INFO, *PCALLBACK_INFO;

HANDLE hProcessEvent,hShutdownEvent, hThread;
HANDLE hDriver;
bool activo =true; 
int NUM_THREADS = 1;
/*void OnCreateProcess( DWORD ProcessId)
{
    HANDLE hProc;
    char pn[255];
    hProc = OpenProcess(PROCESS_QUERY_INFORMATION |PROCESS_VM_READ ,NULL,ProcessId);
    if (hProc == NULL)
        printf("Process handle == null ");
    else
        printf("Process handle == %d " ,hProc);
    
    int retries = 0;
    DWORD ret = GetModuleFileNameEx(hProc,NULL,pn,255);
    while (( ret == 0) && (retries < 2))
    {
        Sleep(1000);
        ret = GetModuleFileNameEx(hProc,NULL,pn,255);
        retries++;
    }
    if (ret == 0)
        printf ("Creado process %d\n", ProcessId);
    else
        printf ("Creado process %d name %s\n", ProcessId, pn);
}

void OnTerminateProcess(DWORD ProcessId)
{
    printf ("Terminado process %d\n", ProcessId);
}*/

/*void RetrieveProcessInfo(CALLBACK_INFO& callbackInfo, CALLBACK_INFO& callbackTemp)
{
    OVERLAPPED ov          = { 0 };
	BOOL       bReturnCode = FALSE;
	DWORD      dwBytesReturned=0;

    // Create an event handle for async notification from the driver
	ov.hEvent = CreateEvent(
		NULL,  // Default security
		TRUE,  // Manual reset
		FALSE, // non-signaled state
		NULL
		); 

	// Get the process info
	bReturnCode = DeviceIoControl(
		hDriver,
		IOCTL_PROCVIEW_GET_PROCINFO,
		0, 
		0,
		&callbackInfo, sizeof(callbackInfo),
		&dwBytesReturned,
		&ov
		);

	// Wait here for the event handle to be set, indicating
	// that the IOCTL processing is completed.
	bReturnCode = GetOverlappedResult(
		hDriver, 
		&ov,
		&dwBytesReturned, 
		TRUE
		);

	CloseHandle(ov.hEvent);

	if ( (callbackTemp.hProcessId!= callbackInfo.hProcessId) && (callbackInfo.hProcessId != 0))
	{
		
		
	}
	
	// Pevent getting duplicated events
	/*if((callbackTemp.ParentId  != callbackInfo.ParentId) ||
	   (callbackTemp.ProcessId != callbackInfo.ProcessId) ||
	   (callbackTemp.bCreate    != callbackInfo.bCreate))
	{
		if(callbackInfo.bCreate)
			// Process creation notification
			OnCreateProcess((DWORD)callbackInfo.ProcessId);
		else
			// Process termination notification
			OnTerminateProcess((DWORD)callbackInfo.ProcessId);
	} // if

	// Store the data for next time
	callbackTemp = callbackInfo;
}


DWORD WINAPI ThreadFunc(LPVOID pvParam)
//DWORD ThreadFunc()
{
    DWORD dwResult; 
    CALLBACK_INFO callbackInfo, callbackTemp;
	HANDLE handles[2] = 
	{
		hShutdownEvent,
		hProcessEvent
	};
	while (true)
	{
	       dwResult = WaitForMultipleObjects(
			sizeof(handles)/sizeof(handles[0]), // number of handles in array
			&handles[0],                        // object-handle array
			FALSE,                              // wait option
			INFINITE                            // time-out interval
			);
	
	    if (handles[dwResult - WAIT_OBJECT_0] == hShutdownEvent)
			break;
	    else
			RetrieveProcessInfo(callbackInfo, callbackTemp);    
		//Sleep(3000);
	}
	return 0;    
}
*/

void InjectDll (HANDLE PID, PVOID pAddr)
{
	//printf("Received Process %d Address %x\n", callbackInfo.hProcessId,callbackInfo.loadLibraryAddress);
		
	HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD) PID);
	if(process == NULL) 
	{
		printf("Error: the specified process couldn't be found.\n");
		
		return ;
	}

	/*
	* Allocate new memory region inside the process's address space.
	*/

	LPVOID arg = (LPVOID)VirtualAllocEx(process, NULL, strlen(SANDBOXIE_DLL_PATH), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(arg == NULL)
	{
		printf("Error: the memory could not be allocated inside the chosen process.\n");
		
		return;
	}
	/*
	* Write the argument to LoadLibraryA to the process's newly allocated memory region.
	*/

	int n = WriteProcessMemory(process, arg, SANDBOXIE_DLL_PATH, strlen(SANDBOXIE_DLL_PATH), NULL);
	if(n == 0) {
		printf("Error: there was no bytes written to the process's address space.\n");
		
		return;
	}

	/*
	* Get address of the LoadLibrary function.
	*/
	LPVOID addr = (LPVOID)GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
	if(addr == NULL) {
		printf("Error: the LoadLibraryA function was not found inside kernel32.dll library.\n");
	}
	/*
	* Inject our DLL into the process's address space.
	*/
	if ((pAddr == NULL) && (addr != NULL))
	{
		pAddr = addr;
	}

	HANDLE threadID = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)pAddr, arg, NULL, NULL);
	if(threadID == NULL) {
		printf("Error: the remote thread could not be created.\n");
		
		return;
	}
	else {
		printf("Success: the remote thread was successfully created.\n");
	}

	/*
	* Close the handle to the process, becuase we've already injected the DLL.
	*/
	CloseHandle(process);
}

BOOL PauseResumeThreadList(DWORD dwOwnerPID, bool bResumeThread) 
{ 
    HANDLE        hThreadSnap = NULL; 
    BOOL          bRet        = FALSE; 
    THREADENTRY32 te32        = {0}; 
 
    // Take a snapshot of all threads currently in the system. 

    hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); 
    if (hThreadSnap == INVALID_HANDLE_VALUE) 
        return (FALSE); 
 
    // Fill in the size of the structure before using it. 

    te32.dwSize = sizeof(THREADENTRY32); 
 
    // Walk the thread snapshot to find all threads of the process. 
    // If the thread belongs to the process, add its information 
    // to the display list.
 
    if (Thread32First(hThreadSnap, &te32)) 
    { 
        do 
        { 
            if (te32.th32OwnerProcessID == dwOwnerPID) 
            {
				HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, te32.th32ThreadID);
				if (bResumeThread)
				{
					//cout << _T("Resuming Thread 0x") << cout.setf( ios_base::hex ) << te32.th32ThreadID << '\n';
					ResumeThread(hThread);
				}
				else
				{
					//cout << _T("Suspending Thread 0x") << cout.setf( ios_base::hex ) << te32.th32ThreadID << '\n';
					SuspendThread(hThread);
				}
				CloseHandle(hThread);
            } 
        }
        while (Thread32Next(hThreadSnap, &te32)); 
        bRet = TRUE; 
    } 
    else 
        bRet = FALSE;          // could not walk the list of threads 
 
    // Do not forget to clean up the snapshot object. 
    CloseHandle (hThreadSnap); 
 
    return (bRet); 
} 


DWORD WINAPI AbrirDriverYMandarPeticiones(LPVOID pvParam)
{
	//int numPeticiones=4;
	int     nRetCode = 0;
    HANDLE  h = INVALID_HANDLE_VALUE;
	CALLBACK_INFO cbInfo;
	DWORD readBytes;
    char    dataBuffer[1024];

	h = CreateFile("\\\\.\\ProcDebugger",GENERIC_READ|GENERIC_WRITE,
                            NULL,NULL,OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,NULL);



    if (h == INVALID_HANDLE_VALUE) {
        nRetCode = GetLastError();
        printf("Error opening Data Device. %d.\n",nRetCode);
        return nRetCode;
    }
	int pepe = *(int *)pvParam;
	DWORD index=pepe;
	while (activo)
	{
		
        DWORD bytesWritten;
        memset(&dataBuffer[0],index,sizeof(dataBuffer));
        if(!WriteFile(h,&dataBuffer[0],sizeof(dataBuffer),&bytesWritten,NULL)) 
		{
            nRetCode = GetLastError();
            //CloseHandle(h);
            printf("Error Writing to Data Device. %d.\n",nRetCode);
            //return nRetCode;
        }
		if (!ReadFile(h, &cbInfo, sizeof(CALLBACK_INFO), &readBytes, NULL))
		//if (!ReadFile(h,&dataBuffer, sizeof(dataBuffer),&readBytes, NULL))

		{
			 nRetCode = GetLastError();
            //CloseHandle(h);
            printf("Error Reading to Data Device. %d.\n",nRetCode);
		}
		else
		{
			printf("Received pid: %d address: %x\n", cbInfo.hProcessId, cbInfo.loadLibraryAddress);
			//printf (dataBuffer);
			//SuspenderProceso
			PauseResumeThreadList((DWORD)cbInfo.hProcessId,false);
			printf("Suspended %d\n",(DWORD)cbInfo.hProcessId);
			InjectDll(cbInfo.hProcessId, cbInfo.loadLibraryAddress);
			//printf("injected %d\n",(DWORD)cbInfo.hProcessId);
			//ReiniciarProceso
			PauseResumeThreadList((DWORD)cbInfo.hProcessId,true);
			printf("Resumed %d\n",(DWORD)cbInfo.hProcessId);
		}
	}
	CloseHandle(h);
	return nRetCode;
}

DWORD StartProcess(LPCTSTR lpApplicationName)
{
	// additional information
	DWORD ret;
	STARTUPINFO si;     
	PROCESS_INFORMATION pi;
	
	// set the size of the structures
	ZeroMemory( &si, sizeof(si) );
	si.cb = sizeof(si);
	ZeroMemory( &pi, sizeof(pi) );
	
	// start the program up
	if (CreateProcess( lpApplicationName,   // the path
					NULL,        // Command line
					NULL,           // Process handle not inheritable
					NULL,           // Thread handle not inheritable
					FALSE,          // Set handle inheritance to FALSE
					0,              // No creation flags
					NULL,           // Use parent's environment block
					NULL,           // Use parent's starting directory 
					&si,            // Pointer to STARTUPINFO structure
					&pi )           // Pointer to PROCESS_INFORMATION structure
		)
	{
		// Close process and thread handles. 
		ret = pi.dwProcessId;
		CloseHandle( pi.hProcess );
		CloseHandle( pi.hThread );
		return ret;
	}
	else
	{
		return -1;
	}
}

#define MAX_PROCESS 30

int PIDs [MAX_PROCESS];

void LanzaProcesosSimulacion(int procesa)
{
/*

procesa indicates the virtualization technology to use

idag.exe
ImmunityDebugger.exe
OLLYDBG.EXE
procexp.exe
Procmon.exe
vboxtray.exe
windbg.exe
Wireshark.exe*/
	char * Process []={"idag.exe","ImmunityDebugger.exe","OLLYDBG.EXE","procexp.exe",
	"Procmon.exe","vboxtray.exe","windbg.exe","Wireshark.exe",NULL};

	char command[1024];
	
	memset(PIDs,sizeof(PIDs),0);

	for (int i =0; i<MAX_PROCESS;i++)
	{
		if (Process[i] == NULL)
			break;
		else if (((procesa == VMWARE) || (procesa == QEMU) || (procesa == BOCHS) || (procesa == WINE)) 
					&& (!strcmp(Process[i],"vboxtray.exe"))){
			PIDs[i] = -1;
			continue;
		}
		memset(command,0,sizeof(command));
		sprintf_s(command,sizeof(command),PROCESS_PATH,Process[i]);
		PIDs[i] = StartProcess(command);
		
	}

	//StartProcess
}
void MataProcesosSimulacion()
{
	HANDLE HP;
	for (int i =0; i<MAX_PROCESS; i++)
	{
		if (PIDs[i] == -1)
		{
			continue;
		}
		else if (PIDs[i] == 0)
		{
			break;
		}
		else
		{
			HP = OpenProcess(PROCESS_ALL_ACCESS,false,PIDs[i]);
			TerminateProcess(HP,1);
		}
	}
}

TCHAR * monitoredKeys [] = {
#ifdef MALWARE_HOME_FILE
	"C:\\malware.exe",
#elif defined( SAMPLE_HOME_FILE)
	"C:\\sample.exe",
#endif
	NULL
	};


void GenerateFiles()
{
	
#if defined(MALWARE_HOME_FILE) || defined(SAMPLE_HOME_FILE)
	TCHAR  destiny [200];
	sprintf_s((TCHAR*)destiny,sizeof(destiny),"copy /Y \"%%PROGRAMFILES%%\\Internet Explorer\\IEXPLORE.EXE\" %s",monitoredKeys[0]);

	system(destiny);

#endif
	HANDLE hFile;
	hFile = CreateFile(OTHER_FILE_NAME, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);

	if (hFile)
	{
		CloseHandle(hFile);
	}
}

void DeleteFiles()
{
	BOOL ret = DeleteFile(OTHER_FILE_NAME);
	ret = DeleteFile(SANDBOXIE_DLL_PATH);
	ret = RemoveDirectory(SANDBOXIE_PATH);
#if defined(MALWARE_HOME_FILE) || defined(SAMPLE_HOME_FILE)
	//TCHAR destiny [200];
	//sprintf_s((TCHAR*)destiny,sizeof(destiny),"%%HOMEDRIVE%%\\%s",monitoredKeys[0],TRUE);


	ret = DeleteFile((LPCSTR)monitoredKeys[0]);
#endif
	
	
}



void PrintHelp()
{
	printf("----------------------------------------------------------\n");
	printf("- Kung-Fu Malware Help                                   -\n");
	printf("-                                                        -\n");
	printf("- Command [option] [--no-sbxie]                          -\n");
	printf("----------------------------------------------------------\n");
	printf("- -h	--help		:	prints help              -\n");
	printf("- -a	--all		:	simulate all sandboxs    -\n");
	printf("- -b	--bochs		:	simulate bochs           -\n");
	printf("- -q	--qemu		:	simulate qemu            -\n");
	printf("- -v	--vmware	:	simulate vmware          -\n");
	printf("- -x	--vbox		:	simulate virtualbox      -\n");
	printf("- -w	--wine		:	simulate wine            -\n");
	printf("- 	--no-sbie	:	no sandboxie check       -\n");
	printf("----------------------------------------------------------\n\n");
}

int ProcesaArgumentos(int argc, char* argv[])
{
	if (argc == 1) //default 
	{
		return ALL_SB;
	}
	else if ((argc == 2) || (argc == 3))
	{
		int ret = FAIL;

		if ((!strcmp(argv[1],"-h")) || (!strcmp(argv[1],"--help")))
		{
			PrintHelp();			
			return FAIL;
		}
		else if ((!strcmp(argv[1],"-a")) || (!strcmp(argv[1],"--all")))
		{
			ret =  ALL_SB;
		}
		else if ((!strcmp(argv[1],"-b")) || (!strcmp(argv[1],"--bochs")))
		{
			ret = BOCHS;
		}
		else if ((!strcmp(argv[1],"-q")) || (!strcmp(argv[1],"--qemu")))
		{
			ret = QEMU;
		}
		else if ((!strcmp(argv[1],"-x")) || (!strcmp(argv[1],"--vbox")))
		{
			ret = VBOX;
		}
		else if ((!strcmp(argv[1],"-v")) || (!strcmp(argv[1],"--vmware")))
		{
			ret = VMWARE;
		}
		else if ((!strcmp(argv[1],"-w")) || (!strcmp(argv[1],"--wine")))
		{
			ret = WINE;
		}
		else
		{
			PrintHelp();
			return FAIL;
		}

		if (argc == 3) //check no Sandboxie. With this check sandboxie check will fail
		{
			if (!strcmp(argv[2],"--no-sbie"))
			{
				SANDBOXIE_DLL_PATH = _T("C:\\Program Files\\Sandbox\\cuckoomon.dll");
				SANDBOXIE_PATH = _T("C:\\Program Files\\Sandbox");
			}
			else
			{
				PrintHelp();
				return FAIL;
			}
		}
		return ret;
	}
	else
	{
		PrintHelp();
		return FAIL;
	}
}
void PreparaDlls(int dllVersion)
{
	CreateDirectory(SANDBOXIE_PATH,NULL);
	char origin[255];
	memset(origin,0,sizeof(origin));
	
	switch (dllVersion)
	{
		case ALL_SB:
			sprintf_s(origin, sizeof(origin),"%s\\%s",ORIGIN_PATH,"SbieDll.dll");					
			break;
		case VMWARE:
			sprintf_s(origin, sizeof(origin),"%s\\%s",ORIGIN_PATH,"SbieDll.vmware.dll");
			break;
		case VBOX:
			sprintf_s(origin, sizeof(origin),"%s\\%s",ORIGIN_PATH,"SbieDll.vbox.dll");
			break;
		case BOCHS:
			sprintf_s(origin, sizeof(origin),"%s\\%s",ORIGIN_PATH,"SbieDll.bochs.dll");
			break;
		case QEMU:
			sprintf_s(origin, sizeof(origin),"%s\\%s",ORIGIN_PATH,"SbieDll.qemu.dll");
			break;
		case WINE:
			sprintf_s(origin, sizeof(origin),"%s\\%s",ORIGIN_PATH,"SbieDll.wine.dll");
			break;
		default:
			sprintf_s(origin, sizeof(origin),"%s\\%s",ORIGIN_PATH,"SbieDll.dll");
			break;
	}
	CopyFile(origin,SANDBOXIE_DLL_PATH,FALSE);
	
}

int main(int argc, char* argv[])
{
    SC_HANDLE hSCManager,hService;
    BOOL bResult;
    SERVICE_STATUS ss;
    unsigned long threadId;

	int procesa = ProcesaArgumentos(argc,argv);
	if (procesa == FAIL)
	{
		return FAIL;
	}
	else
	{
		PreparaDlls(procesa);
	}
	LanzaProcesosSimulacion(procesa);
	Sleep(1000);
    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    
    printf("Load Driver\n");

    if(hSCManager)
    {
        printf("Create Service\n");

        hService = CreateService(hSCManager, "ProcDebugger", 
                                 "ProcDebugger Driver", 
                                  SERVICE_START | DELETE | SERVICE_STOP, 
                                  SERVICE_KERNEL_DRIVER,
                                  SERVICE_DEMAND_START, 
                                  SERVICE_ERROR_IGNORE, 
                                  "D:\\bin\\i386\\ProcDebugger.sys", 
                                  NULL, NULL, NULL, NULL, NULL);

        if(!hService)
        {
            hService = OpenService(hSCManager, "ProcDebugger", 
                       SERVICE_START | DELETE | SERVICE_STOP);

			ControlService(hService, SERVICE_CONTROL_STOP, &ss);            			    
            DeleteService(hService);

            //CloseServiceHandle(hService);
			//DeleteService(hService);
            CloseServiceHandle(hService);                   
			
			//return -1;
			hService = CreateService(hSCManager, "ProcDebugger", 
                                 "ProcDebugger Driver", 
                                  SERVICE_START | DELETE | SERVICE_STOP, 
                                  SERVICE_KERNEL_DRIVER,
                                  SERVICE_DEMAND_START, 
                                  SERVICE_ERROR_IGNORE, 
                                  "D:\\bin\\i386\\ProcDebugger.sys", 
                                  NULL, NULL, NULL, NULL, NULL);

			if (!hService)
			{
				CloseServiceHandle(hSCManager);
				return -1;
			}

        }

        if(hService)
        {           
			SERVICE_STATUS serviceStatus = { 0 };
			bResult = StartService(hService, 0, NULL);
			/*if (bResult)
				bResult = WaitForState(SERVICE_RUNNING, &serviceStatus);	
			else
			{
			    unsigned long ret = GetLastError();
				bResult = (GetLastError() == ERROR_SERVICE_ALREADY_RUNNING);
		    }*/
			// We should call DeleteService() if the SCM reports an error
			// on StartService(). Otherwise, the service will remain loaded
			// in an undesired state
			if (!bResult)
			{
				// Mark the service for deletion.
				ControlService(hService, SERVICE_CONTROL_STOP, &ss);
				DeleteService(hService);
				if (hService != NULL)
				{
					CloseServiceHandle(hService);
					hService = NULL;
				}				
				return -1;
			}
		
            printf("Start Service\n");

            //StartService(hService, 0, NULL);
            /*printf ("Suscribing event");
            
            char szDriverName[60];
            strcpy_s(szDriverName, "\\\\.\\Global\\ProcDebugger");
            hDriver = CreateFile(szDriverName,
					GENERIC_READ | GENERIC_WRITE, 
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					0,                     // Default security
					OPEN_EXISTING,
					FILE_FLAG_OVERLAPPED,  // Perform asynchronous I/O
					0);                    // No template
        
			if(INVALID_HANDLE_VALUE == hDriver)
					return -1;
            hShutdownEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
            hProcessEvent = OpenEvent(SYNCHRONIZE, FALSE, "ProcDebuggerProcessEvent");
            */
			//Sending IRPs to enqueue
			for (int id = 0; id< NUM_THREADS; id++) 
			{
				hThread = CreateThread(NULL, 0,AbrirDriverYMandarPeticiones,&id,0,&threadId);
				if (hThread == NULL)
				{
					MessageBox(GetDesktopWindow(),"Local hooking thread unable to start","LoadDriver",MB_OK);
				}
			}

				
            
            printf("Press Enter to close service\r\n");
            GenerateFiles();
            getchar();
			activo = false;
			CloseServiceHandle(hService);                   
			CloseServiceHandle(hSCManager);
			hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
			if (hSCManager)
			{
				hService = OpenService(hSCManager, "ProcDebugger", 
						   SERVICE_START | DELETE | SERVICE_STOP);
				if (hService)
				{
					

					ControlService(hService, SERVICE_CONTROL_STOP, &ss);            			    
					DeleteService(hService);
	        
					CloseServiceHandle(hService);                   
				}
			}
			//CloseServiceHandle(hSCManager);

            /*ControlService(hService, SERVICE_CONTROL_STOP, &ss);            			    
            //DeleteService(hService);

            //CloseServiceHandle(hService);

            DeleteService(hService);

            ////CloseServiceHandle(hService);
			////DeleteService(hService);
            CloseServiceHandle(hService);                   
			CloseServiceHandle(hSCManager);*/
            
        }

        CloseServiceHandle(hSCManager);
		for (int id = 0; id< NUM_THREADS; id++) 
		{
			system(EMPTY_PATH);
		}
    }
	MataProcesosSimulacion();
	Sleep (2000);
	DeleteFiles();
    
    return 0;


}


