#define WIN32_LEAN_AND_MEAN
//#define PAFISH

#include <winsock2.h>
#include <windows.h>
#include <shlwapi.h>
#include "testIAT.h"
#include "IAThijack.h"
#include <Shellapi.h>
#include <iphlpapi.h>
#include <WinIoCtl.h>

#pragma unmanaged

#include <list>
#include <map>
#include "time.h"
#include <direct.h>

using namespace std;


#define MAX_DISK_SIZE_TO_USE	25 //Tamaño maximo de disco a utilizar
#define MAX_RAM_SIZE_TO_USE		512 // 512 MB
#define MAX_UP_TIME				300000 //Tiempo que esta arriba la maquina Máximo y minimo
#define MIN_UP_TIME				120000
const char		*OTHER_FILE_NAMEA	=	"D:\\Test.txt";
const wchar_t	*OTHER_FILE_NAMEW	=	L"D:\\Test.txt";

// Text buffer for sprintf
char processName[255];
char processInternalName[255];
char dllName    [255];
unsigned long dllSize     = 255;

//list<PHSF_FILTER> filterList;
//PHSF_FILTER dllFilter;
//map<int, PHSF_ACTION> actionDict;

HINSTANCE hDLL;
HWND mainWnd;

// Function pointer types.
/*typedef HRESULT (WINAPI *DirectDrawCreateEx_Type)( GUID FAR *lpGUID, LPVOID *lplpDD, REFIID iid, IUnknown FAR *pUnkOuter );
typedef BOOL (WINAPI *TextOutA_Type)( HDC hdc, int nXStart, int nYStart, LPCTSTR lpString, int cchString);
typedef BOOL (WINAPI *TextOutW_Type)( HDC hdc, int nXStart, int nYStart, LPCWSTR lpString, int cchString);
typedef UINT (WINAPI *SetTextAlign_Type) (HDC hdc, UINT fMode);
typedef BOOL (WINAPI *SetWindowText_Type) (HWND hWnd, LPCTSTR text);
*/
typedef LONG		(WINAPI *RegOpenKeyExA_Type)		( HKEY    hKey, LPCTSTR lpSubKey, DWORD   ulOptions, REGSAM  samDesired, PHKEY   phkResult );
typedef LONG		(WINAPI *RegQueryValueEx_Type)		( HKEY hKey, LPCTSTR lpValueName, LPDWORD lpReserved,LPDWORD lpType,LPBYTE  lpData, LPDWORD lpcbData );
typedef void		(WINAPI *OutputDebugString_Type)	( LPCTSTR lpOutputString );
typedef DWORD		(WINAPI *GetFileAttributes_Type)	( LPCTSTR lpFileName );
typedef BOOL		(WINAPI *GetUserName_TypeA)			( LPTSTR  lpBuffer, LPDWORD lpnSize );
typedef BOOL		(WINAPI *GetUserName_TypeW)			( LPWSTR  lpBuffer, LPDWORD lpnSize );
typedef DWORD		(WINAPI *GetModuleFileNameA_Type)	( HMODULE hModule, LPTSTR  lpFilename, DWORD   nSize);
typedef DWORD		(WINAPI *GetModuleFileNameW_Type)	( HMODULE hModule, LPWSTR  lpFilename, DWORD   nSize);
typedef VOID		(WINAPI *Sleep_Type)				( DWORD dwMilliseconds );
typedef DWORD		(WINAPI *SleepEx_Type)				( DWORD dwMilliseconds, BOOL  bAlertable );
typedef BOOL		(WINAPI *GetDiskFreeSpaceExA_Type)	( LPCTSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailable, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);
typedef BOOL		(WINAPI *GetDiskFreeSpaceExW_Type)	( LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailable, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);
typedef VOID		(WINAPI *GlobalMemoryStatus_Type)	( LPMEMORYSTATUS lpBuffer);
typedef VOID		(WINAPI *GlobalMemoryStatusEx_Type)	( LPMEMORYSTATUSEX lpBuffer);
typedef VOID		(WINAPI *GetSystemInfo_Type)		( LPSYSTEM_INFO lpSystemInfo);
typedef DWORD		(WINAPI *GetTickCount_Type)			();
typedef BOOL		(WINAPI	*CreateProcessA_Type)		( LPCTSTR lpApplicationName, LPTSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCTSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
typedef BOOL		(WINAPI	*CreateProcessW_Type)		( LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
typedef BOOL		(WINAPI *DeleteFileA_Type)			( LPCTSTR lpFileName);
typedef BOOL		(WINAPI *DeleteFileW_Type)			( LPCWSTR lpFileName);
typedef BOOL		(WINAPI *ShellExecuteExA_Type)		( SHELLEXECUTEINFO *pExecInfo);
typedef BOOL		(WINAPI *ShellExecuteExW_Type)		( SHELLEXECUTEINFO *pExecInfo);
typedef HINSTANCE	(WINAPI *ShellExecuteA_Type)		( HWND hwnd, LPCTSTR lpOperation, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd);
typedef HINSTANCE	(WINAPI *ShellExecuteW_Type)		( HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
typedef ULONG		(WINAPI *GetAdaptersAddresses_Type)		( ULONG Family, ULONG Flags, PVOID Reserved,PIP_ADAPTER_ADDRESSES AdapterAddresses, PULONG SizePointer);
typedef HANDLE		(WINAPI *CreateFileA_Type)			( LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD  dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
typedef HANDLE		(WINAPI *CreateFileW_Type)			( LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD  dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
typedef BOOL		(WINAPI *IsNativeVhdBoot_Type)		( BOOL *NativeVhdBoot);
#ifdef WINE
typedef FARPROC		(WINAPI *GetProcAddress_Type)		( HMODULE hModule, LPCSTR lpProcName);
#endif
#ifdef VBOX
typedef DWORD		(WINAPI *WNetGetProviderNameA_Type)	( DWORD dwNetType, LPTSTR lpProviderName, LPDWORD lpBufferSize);
typedef DWORD		(WINAPI *WNetGetProviderNameW_Type)	( DWORD dwNetType, LPWSTR lpProviderName, LPDWORD lpBufferSize);
#endif
typedef BOOL		(WINAPI *DeviceIoControl_Type)		( HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
/*
// Function prototypes.
*/

void WINAPI MyOutputDebugStringA(LPCTSTR lpOutputString);
void WINAPI MyOutputDebugStringW(LPCTSTR lpOutputString);

LONG WINAPI MyRegOpenKeyExA( HKEY    hKey, LPCTSTR lpSubKey, DWORD   ulOptions, REGSAM  samDesired, PHKEY   phkResult);
LONG WINAPI MyRegOpenKeyExW( HKEY    hKey, LPCTSTR lpSubKey, DWORD   ulOptions, REGSAM  samDesired, PHKEY   phkResult);

LONG WINAPI MyRegQueryValueExA(HKEY hKey, LPCTSTR lpValueName, LPDWORD lpReserved,LPDWORD lpType,LPBYTE  lpData, LPDWORD lpcbData);
LONG WINAPI MyRegQueryValueExW(HKEY hKey, LPCTSTR lpValueName, LPDWORD lpReserved,LPDWORD lpType,LPBYTE  lpData, LPDWORD lpcbData);
//Hook structure.

DWORD WINAPI MyGetFileAttributesA( LPCTSTR lpFileName );
DWORD WINAPI MyGetFileAttributesW( LPCTSTR lpFileName );

BOOL WINAPI MyGetUserNameA( LPTSTR  lpBuffer, LPDWORD lpnSize );
BOOL WINAPI MyGetUserNameW( LPWSTR  lpBuffer, LPDWORD lpnSize );

DWORD WINAPI MyGetModuleFileNameA( HMODULE hModule, LPTSTR  lpFilename, DWORD   nSize );
DWORD WINAPI MyGetModuleFileNameW( HMODULE hModule, LPWSTR  lpFilename, DWORD   nSize );

VOID  WINAPI MySleep   ( DWORD dwMilliseconds );
DWORD WINAPI MySleepEx ( DWORD dwMilliseconds, BOOL  bAlertable );

BOOL WINAPI MyGetDiskFreeSpaceExA (LPCTSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailable, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);
BOOL WINAPI MyGetDiskFreeSpaceExW (LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailable, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);

VOID WINAPI MyGlobalMemoryStatus   ( LPMEMORYSTATUS lpBuffer);
VOID WINAPI MyGlobalMemoryStatusEx ( LPMEMORYSTATUSEX lpBuffer);

VOID  WINAPI MyGetSystemInfo			( LPSYSTEM_INFO lpSystemInfo);
DWORD WINAPI MyGetTickCount			();

BOOL WINAPI	 MyCreateProcessA( LPCTSTR lpApplicationName, LPTSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCTSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
BOOL WINAPI	 MyCreateProcessW( LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);

BOOL WINAPI  MyDeleteFileA(LPCTSTR lpFileName);
BOOL WINAPI  MyDeleteFileW(LPCWSTR lpFileName);

HANDLE WINAPI MyCreateFileA( LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD  dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
HANDLE WINAPI MyCreateFileW( LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD  dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);

BOOL WINAPI MyIsNativeVhdBoot ( BOOL *NativeVhdBoot);
#ifdef WINE
FARPROC WINAPI MyGetProcAddress( HMODULE hModule, LPCSTR lpProcName);
#endif 
#ifdef VBOX
DWORD WINAPI MyWNetGetProviderNameA( DWORD dwNetType, LPTSTR lpProviderName, LPDWORD lpBufferSize);
DWORD WINAPI MyWNetGetProviderNameW( DWORD dwNetType, LPWSTR lpProviderName, LPDWORD lpBufferSize);
#endif
// BOOL WINAPI MyGetDiskFreeSpace

BOOL WINAPI  MyShellExecuteExA( SHELLEXECUTEINFO *pExecInfo);
BOOL WINAPI  MyShellExecuteExW( SHELLEXECUTEINFO *pExecInfo);

HINSTANCE WINAPI  MyShellExecuteA( HWND hwnd, LPCTSTR lpOperation, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd);
HINSTANCE WINAPI  MyShellExecuteW( HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);

ULONG WINAPI MyGetAdaptersAddresses( ULONG Family, ULONG Flags, PVOID Reserved,PIP_ADAPTER_ADDRESSES AdapterAddresses, PULONG SizePointer);

BOOL  WINAPI MyDeviceIoControl( HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);

BOOL IsMonitoredFile(LPCTSTR fileName)
{
	BOOL ret = false;

	char * monitoredFiles [] = {
#ifdef VMWARE
		"C:\\WINDOWS\\system32\\drivers\\vmmouse.sys",
		"C:\\WINDOWS\\system32\\drivers\\vmhgfs.sys",
#endif
#ifdef VBOX
		"C:\\WINDOWS\\system32\\drivers\\VBoxMouse.sys",
		"C:\\WINDOWS\\system32\\drivers\\VBoxGuest.sys",
		"C:\\WINDOWS\\system32\\drivers\\VBoxSF.sys",
		"C:\\WINDOWS\\system32\\drivers\\VBoxVideo.sys",

		"C:\\WINDOWS\\system32\\vboxdisp.dll",
		"C:\\WINDOWS\\system32\\vboxhook.dll",
		"C:\\WINDOWS\\system32\\vboxmrxnp.dll",
		"C:\\WINDOWS\\system32\\vboxogl.dll",
		"C:\\WINDOWS\\system32\\vboxoglarrayspu.dll",
		"C:\\WINDOWS\\system32\\vboxoglcrutil.dll",
		"C:\\WINDOWS\\system32\\vboxoglerrorspu.dll",
		"C:\\WINDOWS\\system32\\vboxoglfeedbackspu.dll",
		"C:\\WINDOWS\\system32\\vboxoglpackspu.dll",
		"C:\\WINDOWS\\system32\\vboxoglpassthroughspu.dll",
		"C:\\WINDOWS\\system32\\vboxservice.exe",
		"C:\\WINDOWS\\system32\\vboxtray.exe",
		"C:\\WINDOWS\\system32\\VBoxControl.exe",
		"C:\\program files\\oracle\\virtualbox guest additions\\",
#endif
	NULL

	};

	for (int i = 0; i <100; i ++)
	{
		if ((monitoredFiles[i] == NULL) || ret)
		{
			break;
		}
		ret = !_strcmpi(fileName,monitoredFiles[i]);
	}

	return ret;
}



SDLLHook SKernel32 = 
{
    "Kernel32.dll",
    false, NULL,		// Default hook disabled, NULL function pointer.
    {
        { "OutputDebugStringA",		MyOutputDebugStringA,	NULL },
		{ "OutputDebugStringW",		MyOutputDebugStringW,	NULL },	
		{ "GetFileAttributesA",		MyGetFileAttributesA,	NULL },
		{ "GetFileAttributesW",		MyGetFileAttributesW,	NULL },
		{ "GetModuleFileNameA",		MyGetModuleFileNameA,	NULL },
		{ "GetModuleFileNameW",		MyGetModuleFileNameW,	NULL },
		{ "Sleep",					MySleep,				NULL },
		{ "SleepEx",				MySleepEx,				NULL },
		{ "GetDiskFreeSpaceExA",	MyGetDiskFreeSpaceExA,	NULL },
		{ "GetDiskFreeSpaceExW",	MyGetDiskFreeSpaceExW,	NULL },
		{ "GlobalMemoryStatus",		MyGlobalMemoryStatus,	NULL },	
		{ "GlobalMemoryStatusEx",	MyGlobalMemoryStatusEx,	NULL },
		{ "GetSystemInfo",			MyGetSystemInfo,		NULL },
		{ "GetTickCount",			MyGetTickCount,			NULL },
		{ "CreateProcessA",			MyCreateProcessA,		NULL },
		{ "CreateProcessW",			MyCreateProcessW,		NULL },		
		{ "DeleteFileA",			MyDeleteFileA,			NULL },
		{ "DeleteFileW",			MyDeleteFileW,			NULL },
		{ "CreateFileA",			MyCreateFileA,			NULL },
		{ "CreateFileW",			MyCreateFileW,			NULL },
		{ "IsNativeVhdBoot",		MyIsNativeVhdBoot,		NULL },
		{ "DeviceIoControl",		MyDeviceIoControl,		NULL },		
#ifdef WINE
		{ "GetProcAddress",			MyGetProcAddress,		NULL },
#endif
		//{ "GetDiskFreeSpaceA",	MyGetDiskFreeSpace,		NULL }, Cambiar el numero de sectores y cluster
		//{ "GetDiskFreeSpaceW",	MyGetDiskFreeSpace,		NULL }, Cambiar el numero de sectores y cluster
        { NULL, NULL,NULL }
    }
};
enum
{
    ENUM_MyOutputDebugStringA	= 0,
	ENUM_MyOutputDebugStringW	= 1,
	ENUM_MyGetFileAttributesA	= 2,
	ENUM_MyGetFileAttributesW	= 3,
	ENUM_MyGetModuleFileNameA	= 4,
	ENUM_MyGetModuleFileNameW	= 5,
	ENUM_MySleep				= 6,
	ENUM_MySleepEx				= 7,
	ENUM_GetDiskFreeSpaceExA	= 8,
	ENUM_GetDiskFreeSpaceExW	= 9,
	ENUM_GlobalMemoryStatus		= 10,
	ENUM_GlobalMemoryStatusEx	= 11,
	ENUM_GetSystemInfo			= 12,
	ENUM_GetTickCount			= 13,
	ENUM_CreateProcessA			= 14,
	ENUM_CreateProcessW			= 15,
	ENUM_DeleteFileA			= 16,
	ENUM_DeleteFileW			= 17,
	ENUM_CreateFileA			= 18,
	ENUM_CreateFileW			= 19,
	ENUM_IsNativeVhdBoot		= 20,
	ENUM_DeviceIoControl		= 21,
#ifdef WINE
	ENUM_GetProcAddress,
#endif
	
	//GetDiskFreeSpaceA
	//GetDiskFreeSpaceW
};

void WINAPI MyOutputDebugStringA( LPCTSTR lpOutputString )
{
	int i = 0;
	i+=1;
	return;
}
void WINAPI MyOutputDebugStringW( LPCTSTR lpOutputString )
{
	int i =0;
	i+=2;
	return;
}

DWORD WINAPI MyGetFileAttributesA( LPCTSTR lpFileName )
{
	BOOL isMonitored =false;

#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyGetFileAttributesA called.\n");
#endif
	GetFileAttributes_Type OldFn =
		(GetFileAttributes_Type) SKernel32.Functions[ENUM_MyGetFileAttributesA].OrigFn;	

	isMonitored = IsMonitoredFile(lpFileName);	

	if (isMonitored)
		return FILE_ATTRIBUTE_NORMAL;
	else
		return OldFn (lpFileName);
}

DWORD WINAPI MyGetFileAttributesW( LPCTSTR lpFileName )
{
	BOOL isMonitored =false;

#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyGetFileAttributesW called.\n");
#endif
	GetFileAttributes_Type OldFn =
		(GetFileAttributes_Type) SKernel32.Functions[ENUM_MyGetFileAttributesW].OrigFn;	

	isMonitored = IsMonitoredFile(lpFileName);	

	if (isMonitored)
		return FILE_ATTRIBUTE_NORMAL;
	else
		return OldFn (lpFileName);

}

VOID  WINAPI MySleep   ( DWORD dwMilliseconds )
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MySleep called.\n");
#endif

	Sleep_Type OldFn =
		(Sleep_Type) SKernel32.Functions[ENUM_MySleep].OrigFn;

	
	return OldFn(dwMilliseconds/4);
	//return;
}
DWORD WINAPI MySleepEx ( DWORD dwMilliseconds, BOOL  bAlertable )
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MySleepEx called.\n");
#endif

	SleepEx_Type OldFn =
		(SleepEx_Type) SKernel32.Functions[ENUM_MySleepEx].OrigFn;

	
	return OldFn(dwMilliseconds/4,bAlertable);

	//return 0;
}

BOOL  WINAPI MyDeviceIoControl( HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyDeviceIoControl called.\n");
#endif
	BOOL ret;
	LARGE_INTEGER MAX_SIZE;
	double COLCHON;

	COLCHON = 1.05;
	MAX_SIZE.QuadPart = MAX_DISK_SIZE_TO_USE;
	MAX_SIZE.QuadPart *= (1024 * 1024 * 1024); 
	GET_LENGTH_INFORMATION* returnData;

	DeviceIoControl_Type OldFn =
		(DeviceIoControl_Type) SKernel32.Functions[ENUM_DeviceIoControl].OrigFn;

	ret = OldFn( hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);
	
	if ( (ret != 0) && (dwIoControlCode == IOCTL_DISK_GET_LENGTH_INFO) && 
		 (nOutBufferSize == sizeof(GET_LENGTH_INFORMATION)) )
	{
		COLCHON = 1.05;		
		
		returnData = (GET_LENGTH_INFORMATION*)  lpOutBuffer;
		if (returnData->Length.QuadPart > MAX_SIZE.QuadPart ) 
		{
			returnData->Length.QuadPart = (LONGLONG)(MAX_SIZE.QuadPart * COLCHON);
		}
	}
	
	return ret;
}

BOOL WINAPI MyGetDiskFreeSpaceExA (LPCTSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailable, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyGetDiskFreeSpaceExA called.\n");
#endif
	BOOL ret;
	ULARGE_INTEGER MAX_SIZE;
	double reductionFactor, COLCHON;

	COLCHON = 1.05;
	MAX_SIZE.QuadPart = MAX_DISK_SIZE_TO_USE;
	MAX_SIZE.QuadPart *= (1024 * 1024 * 1024); 
	GetDiskFreeSpaceExA_Type OldFn =
		(GetDiskFreeSpaceExA_Type) SKernel32.Functions[ENUM_GetDiskFreeSpaceExA].OrigFn;

	ret = OldFn(lpDirectoryName, lpFreeBytesAvailable, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
	if ((lpTotalNumberOfBytes != NULL) && ( lpTotalNumberOfBytes->QuadPart > MAX_SIZE.QuadPart ))
	{
		reductionFactor = 1 -((lpTotalNumberOfBytes->QuadPart - MAX_SIZE.QuadPart) / (lpTotalNumberOfBytes->QuadPart *1.0));
		reductionFactor *=COLCHON;
		lpTotalNumberOfBytes->QuadPart = (ULONGLONG)(MAX_SIZE.QuadPart * COLCHON);

		if (lpFreeBytesAvailable != NULL)
		{
			lpFreeBytesAvailable->QuadPart *= (ULONGLONG) reductionFactor;
		}
		if (lpTotalNumberOfFreeBytes != NULL)
		{
			lpTotalNumberOfFreeBytes->QuadPart *= (ULONGLONG) reductionFactor;
		}
	}

	return ret;
}

BOOL WINAPI MyGetDiskFreeSpaceExW (LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailable, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyGetDiskFreeSpaceExW called.\n");
#endif
	BOOL ret;
	ULARGE_INTEGER MAX_SIZE;
	double reductionFactor, COLCHON;

	COLCHON = 1.05;
	MAX_SIZE.QuadPart = MAX_DISK_SIZE_TO_USE;
	MAX_SIZE.QuadPart *= (1024 * 1024 * 1024); 
	GetDiskFreeSpaceExW_Type OldFn =
		(GetDiskFreeSpaceExW_Type) SKernel32.Functions[ENUM_GetDiskFreeSpaceExW].OrigFn;

	ret = OldFn(lpDirectoryName, lpFreeBytesAvailable, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
	if ((lpTotalNumberOfBytes != NULL) && ( lpTotalNumberOfBytes->QuadPart > MAX_SIZE.QuadPart ))
	{
		reductionFactor = 1 -((lpTotalNumberOfBytes->QuadPart - MAX_SIZE.QuadPart) / (lpTotalNumberOfBytes->QuadPart *1.0));
		reductionFactor *=COLCHON;
		lpTotalNumberOfBytes->QuadPart = MAX_SIZE.QuadPart * (ULONGLONG) COLCHON;

		if (lpFreeBytesAvailable != NULL)
		{
			lpFreeBytesAvailable->QuadPart *= (ULONGLONG) reductionFactor;
		}
		if (lpTotalNumberOfFreeBytes != NULL)
		{
			lpTotalNumberOfFreeBytes->QuadPart *= (ULONGLONG) reductionFactor;
		}
	}

	return ret;
}

VOID WINAPI MyGlobalMemoryStatus	( LPMEMORYSTATUS lpBuffer)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyGlobalMemoryStatus called.\n");
#endif
	SIZE_T ramSize = MAX_RAM_SIZE_TO_USE * 1024 * 1024;

	GlobalMemoryStatus_Type OldFn =
		(GlobalMemoryStatus_Type) SKernel32.Functions[ENUM_GlobalMemoryStatus].OrigFn;

	OldFn(lpBuffer);
	if (lpBuffer->dwTotalPhys > ramSize)
	{
		double resize =1 - ( (lpBuffer->dwTotalPhys - ramSize) / (double)lpBuffer->dwTotalPhys);

		lpBuffer->dwTotalPhys = ramSize;
		lpBuffer->dwAvailPhys *= (SIZE_T) resize;
	}
	
	
}
VOID WINAPI MyGlobalMemoryStatusEx ( LPMEMORYSTATUSEX lpBuffer)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyGlobalMemoryStatusEx called.\n");
#endif
	DWORDLONG ramSize = MAX_RAM_SIZE_TO_USE * 1024 * 1024;

	GlobalMemoryStatusEx_Type OldFn =
		(GlobalMemoryStatusEx_Type) SKernel32.Functions[ENUM_GlobalMemoryStatusEx].OrigFn;

	OldFn(lpBuffer);
	if (lpBuffer->ullTotalPhys > ramSize)
	{
		double resize = 1 - ( (lpBuffer->ullTotalPhys - ramSize) / (double)lpBuffer->ullTotalPhys);

		lpBuffer->ullTotalPhys = ramSize;
		lpBuffer->ullAvailPhys *= (DWORDLONG) resize;
	}
}

VOID WINAPI MyGetSystemInfo	( LPSYSTEM_INFO lpSystemInfo)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyGetSystemInfo called.\n");
#endif

	GetSystemInfo_Type OldFn =
		(GetSystemInfo_Type) SKernel32.Functions[ENUM_GetSystemInfo].OrigFn;

	OldFn(lpSystemInfo);
	if (lpSystemInfo->dwNumberOfProcessors > 1)
	{
		lpSystemInfo->dwNumberOfProcessors = 1;
		lpSystemInfo->dwActiveProcessorMask = 0x01;
	}

}
DWORD firstTick = 0;
DWORD realTick = 0;

DWORD WINAPI MyGetTickCount()
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyGetTickCount called.\n");
#endif

	GetTickCount_Type OldFn =
		(GetTickCount_Type) SKernel32.Functions[ENUM_GetTickCount].OrigFn;

	DWORD ret = OldFn();

	if (ret > MAX_UP_TIME)
	{
		srand((int) time(NULL));
		int t = rand();
		
		if (firstTick > 0)
		{
			
			firstTick += (ret - realTick);
			realTick = ret;
		}
		else
		{
				
			int d = rand();
			if (d == 0)
				d+=1;
			unsigned long final = (t*MAX_UP_TIME/d);
			final %=  MAX_UP_TIME;
			if (final < MIN_UP_TIME)
			{
				final += MIN_UP_TIME;
				//final = final % MAX_UP_TIME;
			}
			firstTick = final;
			realTick = ret;
		}
		ret = firstTick;
	}
	return ret;

}

BOOL WINAPI	 MyCreateProcessA( LPCTSTR lpApplicationName, LPTSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCTSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyCreateProcessA called.\n");
#endif

	CreateProcessA_Type OldFn =
		(CreateProcessA_Type) SKernel32.Functions[ENUM_CreateProcessA].OrigFn;

	return OldFn(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory,lpStartupInfo, lpProcessInformation);

}
BOOL WINAPI	 MyCreateProcessW( LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyCreateProcessW called.\n");
#endif

	CreateProcessW_Type OldFn =
		(CreateProcessW_Type) SKernel32.Functions[ENUM_CreateProcessW].OrigFn;

	return OldFn(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory,lpStartupInfo, lpProcessInformation);

}

BOOL WINAPI  MyDeleteFileA(LPCTSTR lpFileName)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyDeleteFileA called.\n");
#endif

	DeleteFileA_Type OldFn =
		(DeleteFileA_Type) SKernel32.Functions[ENUM_DeleteFileA].OrigFn;

	return OldFn(lpFileName);

}
BOOL WINAPI  MyDeleteFileW(LPCWSTR lpFileName)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyDeleteFileW called.\n");
#endif

	DeleteFileW_Type OldFn =
		(DeleteFileW_Type) SKernel32.Functions[ENUM_DeleteFileW].OrigFn;

	return OldFn(lpFileName);
}

HANDLE WINAPI MyCreateFileA( LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD  dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{

	char * monitoredCreateFiles [] = {
#ifdef VBOX
		"\\\\.\\VBoxMiniRdrDN",
		"\\\\.\\pipe\\VBoxMiniRdDN",
		"\\\\.\\VBoxTrayIPC",
		"\\\\.\\pipe\\VBoxTrayIPC",
#endif 
#ifdef VMWARE
		"\\\\.\\HGFS",
		"\\\\.\\vmci",
#endif
		NULL
	};
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyCreateFileA called.\n");
#endif

	CreateFileA_Type OldFn =
		(CreateFileA_Type) SKernel32.Functions[ENUM_CreateFileA].OrigFn;

	int ARRAY_NAMES = (sizeof (monitoredCreateFiles)/4) - 1;
	const char * ptrC;
	for (int i = 0; i < ARRAY_NAMES; i++)
	{
		ptrC = StrStrI (lpFileName,monitoredCreateFiles[i]);
		if (ptrC != NULL )
		{
			//Found device
			
			
			return OldFn (OTHER_FILE_NAMEA,
							dwDesiredAccess, 
							dwShareMode, 
							lpSecurityAttributes, 
							dwCreationDisposition | CREATE_ALWAYS, 
							dwFlagsAndAttributes, 
							hTemplateFile);
		}

	}
	return OldFn(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

HANDLE WINAPI MyCreateFileW( LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD  dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
	
	wchar_t * monitoredCreateFiles [] = {
#ifdef VBOX
		L"\\\\.\\VBoxMiniRdrDN",
		L"\\\\.\\pipe\\VBoxMiniRdDN",
		L"\\\\.\\VBoxTrayIPC",
		L"\\\\.\\pipe\\VBoxTrayIPC",
#endif 
#ifdef VMWARE
		L"\\\\.\\HGFS",
		L"\\\\.\\vmci",
#endif
		NULL

	};
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyCreateFileW called.\n");
#endif

	CreateFileW_Type OldFn =
		(CreateFileW_Type) SKernel32.Functions[ENUM_CreateFileW].OrigFn;

	int ARRAY_NAMES = (sizeof (monitoredCreateFiles)/4) - 1;
	for (int i = 0; i < ARRAY_NAMES; i++)
	{
		if (StrStrIW(lpFileName,monitoredCreateFiles[i]) != NULL)
		{
			i++;
			//Found device
			return OldFn(OTHER_FILE_NAMEW, 
							dwDesiredAccess, 
							dwShareMode, 
							lpSecurityAttributes, 
							dwCreationDisposition | CREATE_ALWAYS, 
							dwFlagsAndAttributes, 
							hTemplateFile);			
		}

	}
	return OldFn(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

}

BOOL WINAPI MyIsNativeVhdBoot (BOOL *NativeVhdBoot)
{
	*NativeVhdBoot = TRUE;
	return TRUE;

}

#ifdef WINE

BOOL FalseWineFuncion (LPCSTR in,LPCSTR in2, INT lon)
{
	return FALSE;
}
FARPROC WINAPI MyGetProcAddress( HMODULE hModule, LPCSTR lpProcName)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyGetProcAddress called.\n");
#endif
	GetProcAddress_Type OldFn =
		(GetProcAddress_Type) SKernel32.Functions[ENUM_GetProcAddress].OrigFn;

	FARPROC ret =  OldFn(hModule,lpProcName);
	if (!strcmp(lpProcName,"wine_get_unix_file_name"))
	{
		return  (FARPROC) FalseWineFuncion;
	}
	else
	{
		return ret;
	}

}
#endif 

//___________________________________________________________________________

SDLLHook SShell32 = 
{
    "Shell32.dll",
    false, NULL,		// Default hook disabled, NULL function pointer.
    {
		{ "ShellExecuteExA",		MyShellExecuteExA ,	NULL },
		{ "ShellExecuteExW",		MyShellExecuteExA ,	NULL },
		{ "ShellExecuteA",			MyShellExecuteA ,	NULL },
		{ "ShellExecuteW",			MyShellExecuteW ,	NULL },
        { NULL, NULL,NULL }
    }
};

enum
{
    ENUM_MyShellExecuteExA	= 0,
	ENUM_MyShellExecuteExW	= 1,
	ENUM_MyShellExecuteA	= 2,
	ENUM_MyShellExecuteW	= 3
};

BOOL WINAPI  MyShellExecuteExA( SHELLEXECUTEINFO *pExecInfo)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyShellExecuteExA called.\n");
#endif

	ShellExecuteExA_Type OldFn =
		(ShellExecuteExA_Type) SKernel32.Functions[ENUM_MyShellExecuteExA].OrigFn;

	return OldFn(pExecInfo);

}
BOOL WINAPI  MyShellExecuteExW( SHELLEXECUTEINFO *pExecInfo)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyShellExecuteExW called.\n");
#endif

	ShellExecuteExW_Type OldFn =
		(ShellExecuteExW_Type) SKernel32.Functions[ENUM_MyShellExecuteExW].OrigFn;

	return OldFn(pExecInfo);

}

HINSTANCE WINAPI  MyShellExecuteA( HWND hwnd, LPCTSTR lpOperation, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyShellExecuteA called.\n");
#endif

	ShellExecuteA_Type OldFn =
		(ShellExecuteA_Type) SKernel32.Functions[ENUM_MyShellExecuteA].OrigFn;

	return OldFn( hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd);

}
HINSTANCE WINAPI  MyShellExecuteW( HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyShellExecuteW called.\n");
#endif

	ShellExecuteW_Type OldFn =
		(ShellExecuteW_Type) SKernel32.Functions[ENUM_MyShellExecuteW].OrigFn;

	return OldFn( hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd);

}
//___________________________________________________________________________


SDLLHook SIphlpapi = 
{
    "Iphlpapi.dll",
    false, NULL,		// Default hook disabled, NULL function pointer.
    {
		{ "GetAdaptersAddresses",		MyGetAdaptersAddresses ,	NULL },
        { NULL, NULL,NULL }
    }
};

enum
{
    ENUM_MyGetAdaptersAddresses	= 0,
};

ULONG WINAPI MyGetAdaptersAddresses( ULONG Family, ULONG Flags, PVOID Reserved,PIP_ADAPTER_ADDRESSES AdapterAddresses, PULONG SizePointer)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyGetAdaptersAddresses called.\n");
#endif

	char * monitoredMAC [] = {
	#if defined(VMWARE)
		"\x00\x05\x69",
		"\x00\x0C\x29", 
		"\x00\x1C\x14",
		"\x00\x50\x56",
	#endif
	#if defined(VBOX)
		"\x08\x00\x27",
	#endif 
		NULL
	};

	int ARRAY_MACS = (sizeof (monitoredMAC)/4) - 1;

	char * MACNames [] = {
	#if defined(VMWARE)
		"VMware ",
	#endif
		NULL
	};
	int ARRAY_MACS_NAMES = (sizeof (MACNames)/4) - 1;

	GetAdaptersAddresses_Type OldFn =
		(GetAdaptersAddresses_Type) SIphlpapi.Functions[ENUM_MyGetAdaptersAddresses].OrigFn;

	ULONG ret = OldFn( Family, Flags, Reserved, AdapterAddresses, SizePointer);
	if ((ret ==  ERROR_SUCCESS) && (ARRAY_MACS > 0))
	{
		PIP_ADAPTER_ADDRESSES pAux;
		pAux = AdapterAddresses;
		
		srand ( (int) time(NULL) );
		int random_number = rand();
		random_number = random_number % ARRAY_MACS ;
		
		while (pAux) {
			if (pAux->PhysicalAddressLength==0x6){				
				pAux->PhysicalAddress[0] = monitoredMAC[random_number][0];
				pAux->PhysicalAddress[1] = monitoredMAC[random_number][1];
				pAux->PhysicalAddress[2] = monitoredMAC[random_number][2];
			}
#ifdef VMWARE
			wchar_t  charAux[256];
			//try
			//{

				size_t len = wcslen(pAux->Description);
				memset (charAux,0,sizeof(charAux));
				
				wcsncpy(charAux, pAux->Description, len /2 );
				//wcsncpy_s(charAux, sizeof(charAux), pAux->Description, len - wcslen(L"VMware %s  ") );
				swprintf_s(pAux->Description,len, L"VMware %s",charAux);
			/*}
			catch (exception& e)
			{
				charAux[0] = NULL;
			}*/

			
#endif
			pAux = pAux->Next;
		}
			
	}
	return ret;

}
//___________________________________________________________________________


#ifdef VBOX
SDLLHook SMpr = 
{
    "Mpr.dll",
    false, NULL,		// Default hook disabled, NULL function pointer.
    {
		{ "WNetGetProviderNameA",		MyWNetGetProviderNameA ,	NULL },
		{ "WNetGetProviderNameW",		MyWNetGetProviderNameW ,	NULL },
        { NULL, NULL,NULL }
    }
};

enum
{
    ENUM_MyWNetGetProviderNameA	= 0,
	ENUM_MyWNetGetProviderNameW	= 1,
};

ULONG WINAPI MyWNetGetProviderNameA( DWORD dwNetType, LPTSTR lpProviderName, LPDWORD lpBufferSize)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyWNetGetProviderNameA called.\n");
#endif

	int lenOut = strlen("VirtualBox Shared Folders"	);

	if ((dwNetType == WNNC_NET_RDR2SAMPLE) && ((*lpBufferSize) > lenOut))
	{
		strcpy_s(lpProviderName,(*lpBufferSize),"VirtualBox Shared Folders");
		*lpBufferSize = lenOut;
		return NO_ERROR;
	}
	else
	{
	
	
		WNetGetProviderNameA_Type OldFn =
			(WNetGetProviderNameA_Type) SMpr.Functions[ENUM_MyWNetGetProviderNameA].OrigFn;

		ULONG ret = OldFn( dwNetType, lpProviderName, lpBufferSize);
		
		return ret;
	}

}

ULONG WINAPI MyWNetGetProviderNameW( DWORD dwNetType, LPWSTR lpProviderName, LPDWORD lpBufferSize)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyWNetGetProviderNameW called.\n");
#endif

	
	
	size_t lenOut = wcslen(L"VirtualBox Shared Folders"	);

	if ((dwNetType == WNNC_NET_RDR2SAMPLE) && ((*lpBufferSize) > lenOut))
	{
		swprintf_s(lpProviderName, *lpBufferSize, L"VirtualBox Shared Folders");
		*lpBufferSize = lenOut;
		return NO_ERROR;
	}
	else
	{
	
	
		WNetGetProviderNameW_Type OldFn =
			(WNetGetProviderNameW_Type) SMpr.Functions[ENUM_MyWNetGetProviderNameW].OrigFn;

		ULONG ret = OldFn( dwNetType, lpProviderName, lpBufferSize);
		
		return ret;
	}

}

#endif
//___________________________________________________________________________

SDLLHook SAdvapi32 = 
{
    "Advapi32.dll",
    false, NULL,		// Default hook disabled, NULL function pointer.
    {
		{ "RegOpenKeyExA",		MyRegOpenKeyExA ,	NULL },
		{ "RegOpenKeyExW",		MyRegOpenKeyExW,	NULL },	
		{ "RegQueryValueExA",	MyRegQueryValueExA, NULL },
		{ "RegQueryValueExW",	MyRegQueryValueExW,	NULL },
		{ "GetUserNameA",		MyGetUserNameA,		NULL },
		{ "GetUserNameW",		MyGetUserNameW,		NULL },
        { NULL, NULL,NULL }
    }
};

enum
{
    ENUM_MyRegOpenKeyExA	= 0,
	ENUM_MyRegOpenKeyExW	= 1,
	ENUM_MyRegQueryValueExA = 2,
	ENUM_MyRegQueryValueExW = 3,
	ENUM_MyGetUserNameA		= 4,
	ENUM_MyGetUserNameW		= 5,

};


BOOL IsMonitoredSubKey(LPCTSTR lpSubKey)
{
	
	BOOL ret = false;

	char * monitoredKeys [] = {
#ifdef VMWARE
		"SOFTWARE\\VMware, Inc.\\VMware Tools",
#endif
#ifdef VBOX
		"SOFTWARE\\Oracle\\VirtualBox Guest Additions",
		"HARDWARE\\ACPI\\DSDT\\VBOX__",
		"HARDWARE\\ACPI\\FADT\\VBOX__",
		"HARDWARE\\ACPI\\RSDT\\VBOX__",
		"HARDWARE\\Description\\System",
#endif
#ifdef WINE
		"SOFTWARE\\Wine",
#endif
#ifdef VBOX
		"SYSTEM\\ControlSet001\\Services\\VBoxGuest",
		"SYSTEM\\ControlSet001\\Services\\VBoxMouse",
		"SYSTEM\\ControlSet001\\Services\\VBoxService",
		"SYSTEM\\ControlSet001\\Services\\VBoxSF",
		"SYSTEM\\ControlSet001\\Services\\VBoxVideo",
#endif
#if defined (VBOX) || defined (VMWARE) || defined(QEMU)
		"HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0",
#endif
#if defined(VMWARE)
		"HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 1\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0",
		"HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 2\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0",
#endif
		NULL
	};

	for (int i = 0; i <100; i ++)
	{
		if ((monitoredKeys[i] == NULL) || ret)
		{
			break;
		}
		ret = !_strcmpi(lpSubKey,monitoredKeys[i]);
	}

	return ret;
}


HKEY lastOpenKey;
char lastOpenKeyPath [1024];

map<LPCTSTR,map<LPCSTR,LPCSTR>> create_map()
{
	map<LPCTSTR,map<LPCSTR,LPCSTR>> m;
	map<LPCTSTR,LPCTSTR> aux,aux2,aux3,aux4,aux5;

#if defined(VBOX) && defined(VMWARE) && defined(QEMU)
	aux["Identifier"]="QEMU VBOX VMWARE "; //PAFISH
#elif defined(VBOX)
	aux["Identifier"]="VBOX"; 
#elif defined(VMWARE)
	aux["Identifier"]="VMWARE";
#elif defined(QEMU)
	aux["Identifier"]="QEMU"; 
#endif

#if defined(VBOX) || defined(VMWARE) || defined(QEMU)
	m["HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0"]=aux;
#endif

#if defined(VMWARE)
	aux2["Identifier"]="VMWARE";
	m["HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 1\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0"]=aux2;
	m["HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 2\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0"]=aux2;
#endif

#if defined(VBOX) && defined(QEMU) && defined(BOCHS)
	aux3["SystemBiosVersion"] = "VBOX QEMU BOCHS "; 
	aux3["VideoBiosVersion"] = "VIRTUALBOX";
	aux3["SystemBiosDate"] = "06/23/99";
#elif defined (VBOX)
	aux3["SystemBiosVersion"] = "VBOX"; 
	aux3["VideoBiosVersion"] = "VIRTUALBOX";
	aux3["SystemBiosDate"] = "06/23/99";

#elif defined(QEMU)
	aux3["SystemBiosVersion"] = "QEMU";

#elif defined(BOCHS)
	aux3["SystemBiosVersion"] = "BOCHS";
#endif
	m["HARDWARE\\Description\\System"]=aux3;


	return m;
}

BOOL IsMonitoredSubKeyValue(HKEY hKey, LPCTSTR lpValueName, LPBYTE  lpData, LPDWORD lpcbData)
{
	BOOL ret = false;
	map<LPCTSTR,map<LPCTSTR,LPCTSTR>> m;

	m = create_map();
	
	if (hKey == lastOpenKey)
	{
		map<LPCTSTR,map<LPCTSTR,LPCTSTR>>::iterator search;
		
		for (search = m.begin() ; search != m.end();search++)
		{
			if (!_strcmpi(search->first,lastOpenKeyPath))
			{
				map<LPCSTR,LPCSTR>::iterator search2; //= search->second.find(lpValueName);	
				for (search2 = search->second.begin() ; search2 != search->second.end();search2++)
				{
					if (!_strcmpi(search2->first,lpValueName))
					{
						memset(lpData,0,sizeof(char)*(strlen(search2->second)+1));
						memcpy_s(lpData,sizeof(char)*strlen(search2->second),(LPCSTR)search2->second,sizeof(char)*strlen(search2->second));
						*lpcbData = sizeof(char)*strlen(search2->second);
						ret = true;
						break;
					}
					
				}
				break;
			}
		}
	}
	m.clear();
	return ret;
}


LONG WINAPI MyRegOpenKeyExA( HKEY    hKey, LPCTSTR lpSubKey, DWORD   ulOptions, REGSAM  samDesired, PHKEY   phkResult)
{
	LONG ret ;
	BOOL isMonitored =false;

#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyRegOpenKeyExA called.\n");
#endif
	RegOpenKeyExA_Type OldFn =
		(RegOpenKeyExA_Type) SAdvapi32.Functions[ENUM_MyRegOpenKeyExA].OrigFn;	

	isMonitored = IsMonitoredSubKey(lpSubKey);	
	ret = OldFn (hKey, lpSubKey,ulOptions,samDesired,phkResult);
	if ((ret == ERROR_SUCCESS)|| isMonitored)
	{
		lastOpenKey = *phkResult;
		memset (lastOpenKeyPath,0,1024*sizeof(char));
		strcpy_s(lastOpenKeyPath, sizeof (lastOpenKeyPath), lpSubKey);
	}
	if (isMonitored)
		return ERROR_SUCCESS;
	else
		return ret;
	
}

LONG WINAPI MyRegOpenKeyExW( HKEY    hKey, LPCTSTR lpSubKey, DWORD   ulOptions, REGSAM  samDesired, PHKEY   phkResult)
{
	LONG ret;
	BOOL isMonitored =false;

#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyRegOpenKeyExW called.\n");
#endif
	RegOpenKeyExA_Type OldFn =
		(RegOpenKeyExA_Type) SAdvapi32.Functions[ENUM_MyRegOpenKeyExW].OrigFn;	

	isMonitored = IsMonitoredSubKey(lpSubKey);	
	ret = OldFn (hKey, lpSubKey,ulOptions,samDesired,phkResult);
	if ((ret == ERROR_SUCCESS)|| isMonitored)
	{

		lastOpenKey = *phkResult;
		memset (lastOpenKeyPath,0,1024*sizeof(char));
		strcpy_s(lastOpenKeyPath, sizeof (lastOpenKeyPath), lpSubKey);
	}
	if (isMonitored)
		return ERROR_SUCCESS;
	else
		return ret;
}



LONG WINAPI MyRegQueryValueExA(HKEY hKey, LPCTSTR lpValueName, LPDWORD lpReserved,LPDWORD lpType,LPBYTE  lpData, LPDWORD lpcbData)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyRegQueryValueExA called.\n");
#endif
	RegQueryValueEx_Type OldFn =
		(RegQueryValueEx_Type) SAdvapi32.Functions[ENUM_MyRegQueryValueExA].OrigFn;	
	if (IsMonitoredSubKeyValue(hKey,lpValueName,lpData,lpcbData) )
		return ERROR_SUCCESS;
	else
		return OldFn ( hKey,  lpValueName,  lpReserved, lpType,  lpData, lpcbData);

}

LONG WINAPI MyRegQueryValueExW(HKEY hKey, LPCTSTR lpValueName, LPDWORD lpReserved,LPDWORD lpType,LPBYTE  lpData, LPDWORD lpcbData)
{
#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyRegQueryValueExW called.\n");
#endif
	RegQueryValueEx_Type OldFn =
		(RegQueryValueEx_Type) SAdvapi32.Functions[ENUM_MyRegQueryValueExW].OrigFn;	
	if (IsMonitoredSubKeyValue(hKey,lpValueName,lpData,lpcbData ) )
		return ERROR_SUCCESS;
	else
		return OldFn ( hKey,  lpValueName,  lpReserved, lpType,  lpData, lpcbData);

}

BOOL WINAPI MyGetUserNameA( LPTSTR  lpBuffer, LPDWORD lpnSize )
{
	BOOL ret;
	
	char * userNames [] = {
#ifdef USERVIRUS
		"VIRUS",
#endif
#ifdef USERMALWARE
		"MALWARE",
#endif
#ifdef USERSANDBOX
		"SANDBOX",
#endif
		NULL
	};
	int ARRAY_NAMES = (sizeof (userNames)/4) - 1;

#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyGetUserNameA called.\n");
#endif
	GetUserName_TypeA OldFn =
		(GetUserName_TypeA) SAdvapi32.Functions[ENUM_MyGetUserNameA].OrigFn;	
	if (ARRAY_NAMES == 0)
	{
		ret = OldFn ( lpBuffer,  lpnSize);
	}
	else
	{
		if ((*lpnSize > 5) && (*lpnSize < 8))
		{ //Copio VIRUS				
			strcpy_s(lpBuffer, *lpnSize, "VIRUS");
			ret = TRUE;
		}
		else if (*lpnSize > 8)
		{ //Copio VIRUS MALWARE SANDBOX en modo random
			srand ( (int) time(NULL) );
			int random_number = rand();
			random_number = random_number % ARRAY_NAMES ;
			int lc = strlen (userNames[random_number]);
			strcpy_s(lpBuffer, *lpnSize , userNames[random_number]);
			ret = TRUE;	
		}
		else
		{
			ret = OldFn ( lpBuffer,  lpnSize);
		}
	}
	return ret;

}
BOOL WINAPI MyGetUserNameW( LPWSTR  lpBuffer, LPDWORD lpnSize )
{
	BOOL ret;
	
	WCHAR * userNames [] = {
#ifdef USERVIRUS
		L"VIRUS",
#endif
#ifdef USERMALWARE
		L"MALWARE",
#endif
#ifdef USERSANDBOX
		L"SANDBOX",
#endif
		NULL
	};
	int ARRAY_NAMES = (sizeof (userNames)/4) - 1;

#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyGetUserNameW called.\n");
#endif
	GetUserName_TypeW OldFn =
		(GetUserName_TypeW) SAdvapi32.Functions[ENUM_MyGetUserNameW].OrigFn;	
	if (ARRAY_NAMES == 0)
	{
		ret = OldFn ( lpBuffer,  lpnSize);
	}
	else
	{
		if ((*lpnSize > 5) && (*lpnSize < 8))
		{ //Copio VIRUS				
			//wcscpy_s(lpBuffer, *lpnSize, userNames[0]);
			const wchar_t* format = L"%S";
			/*swprintf_s((wchar_t*) lpBuffer, *lpnSize, format,"VIRUS");*/
			swprintf_s( lpBuffer, *lpnSize, format,"VIRUS");
			ret = TRUE;
		}
		else if (*lpnSize > 8)
		{ //Copio VIRUS MALWARE SANDBOX en modo random
			srand ( (int) time(NULL) );
			int random_number = rand();
			random_number = random_number % ARRAY_NAMES ;
			//int ls = strlen (userNames[random_number]);
			const wchar_t* format = L"%s";
			/*swprintf_s((wchar_t*) lpBuffer, *lpnSize, format,userNames[random_number]);*/
			swprintf_s(lpBuffer, *lpnSize, format,userNames[random_number]);
			ret = TRUE;	
		}
		else
		{
			ret = OldFn ( lpBuffer,  lpnSize);
		}
	}
	return ret;

}

void ChangePathsW (LPWSTR lpFileName, WCHAR* pathName, GetModuleFileNameW_Type oldF)
{
	WCHAR pathAux[500];
	int pathsize = sizeof(pathAux);

	oldF(NULL, pathAux, pathsize);

	PathRemoveFileSpecW(lpFileName);
	//printf ("Remove fileName %S\n",path);
	PathStripPathW(pathAux);
	//printf ("FileName %S\n",pathAux);
	PathAppendW(lpFileName,pathName);
	//printf ("PathAppend %S\n",path);
	PathAppendW(lpFileName,pathAux);
	//printf ("Final path %S\n",path);
}


void ChangePaths (LPTSTR lpFileName, TCHAR* pathName, GetModuleFileNameA_Type oldF)
{
	TCHAR pathAux[500];
	int pathsize = sizeof(pathAux);

	oldF(NULL, pathAux, pathsize);

	PathRemoveFileSpec(lpFileName);
	//printf ("Remove fileName %S\n",path);
	PathStripPath(pathAux);
	//printf ("FileName %S\n",pathAux);
	PathAppend(lpFileName,pathName);
	//printf ("PathAppend %S\n",path);
	PathAppend(lpFileName,pathAux);
	//printf ("Final path %S\n",path);
}

DWORD WINAPI MyGetModuleFileNameA( HMODULE hModule, LPTSTR  lpFilename, DWORD   nSize)
{
	DWORD ret;
	
	char * pathNames [] = {
#ifdef PATHVIRUS
		"VIRUS",
#endif
#ifdef PATHSAMPLE
		"SAMPLE",
#endif
#ifdef PATHSANDBOX
		"SANDBOX",
#endif
		NULL
	};
	int ARRAY_NAMES = (sizeof (pathNames)/4) - 1;

#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyGetModuleFileNameA called.\n");
#endif

	GetModuleFileNameA_Type OldFn =
		(GetModuleFileNameA_Type) SKernel32.Functions[ENUM_MyGetModuleFileNameA].OrigFn;	
	
	ret = OldFn ( hModule,  lpFilename, nSize);
	if ((hModule == NULL) && (ARRAY_NAMES > 0)) //Solo me interesa el program name, no otros modules
	{
		int leftSize = nSize - sizeof(lpFilename);
		if (leftSize >5)
		{
			switch (leftSize)
			{
				case 0:
					break;
				//case 6: //VIRUS
				//	break;
				//case 7: //SAMPLE
				//	
				//	break;
				//case 8: //SANDBOX
				//	break;
				default:
					srand ( (int) time(NULL) );
					int random_number = rand();
					random_number = random_number % ARRAY_NAMES ;
					ChangePaths(lpFilename, pathNames[random_number],OldFn);
					
					
			}
		}
	}
	
	return ret;

}

DWORD WINAPI MyGetModuleFileNameW( HMODULE hModule, LPWSTR  lpFilename, DWORD   nSize)
{
		DWORD ret;
	
	WCHAR * pathNames [] = {
#ifdef PATHVIRUS
		L"VIRUS",
#endif
#ifdef PATHSAMPLE
		L"SAMPLE",
#endif
#ifdef PATHSANDBOX
		L"SANDBOX",
#endif
		NULL
	};
	int ARRAY_NAMES = (sizeof (pathNames)/4) - 1;

#ifdef SHOWOUTPUTDEBUGSTRING
	OutputDebugString ("TESTDLL: MyGetModuleFileNameW called.\n");
#endif

	GetModuleFileNameW_Type OldFn =
		(GetModuleFileNameW_Type) SKernel32.Functions[ENUM_MyGetModuleFileNameW].OrigFn;	
	
	ret = OldFn ( hModule,  lpFilename, nSize);
	if ((hModule == NULL) && (ARRAY_NAMES >0)) //Solo me interesa el program name, no otros modules
	{
		
		int leftSize = nSize - sizeof(lpFilename);
		if (leftSize >5)
		{
			switch (leftSize)
			{
				case 0:
					break;
				//case 6: //VIRUS
				//	break;
				//case 7: //SAMPLE
				//	
				//	break;
				//case 8: //SANDBOX
				//	break;
				default:
					srand ( (int) time(NULL) );
					int random_number = rand();
					random_number = random_number % ARRAY_NAMES ;
					ChangePathsW(lpFilename, pathNames[random_number],OldFn);
					
					
			}
		}
		
	}
	
	return ret;

}

void HookCalls(bool set)
{
	HookAPICalls(&SKernel32,set);
	HookAPICalls(&SAdvapi32,set);
	HookAPICalls(&SShell32,set);
	HookAPICalls(&SIphlpapi,set);
#ifdef VBOX
	HookAPICalls(&SMpr,set);
#endif 
	/*if ( _stricmp( processInternalName, "bend.exe" ) == 0 )
		HookAPICalls( &D3DHook ,set );
	else if (_stricmp( processInternalName, "app2.exe" ) == 0 )
		HookAPICalls(&SSetWindowText, set);
	else
	{
		HookAPICalls(&SReturnText,set);
	}*/
}


BOOL APIENTRY DllMain( HINSTANCE hModule, DWORD fdwReason, LPVOID lpReserved )
{    
	switch (fdwReason)
	{
		case DLL_PROCESS_ATTACH:
		{
			hDLL = hModule;
//			dllFilter = NULL;

			// We don't need thread notifications for what we're doing.  Thus, get
			// rid of them, thereby eliminating some of the overhead of this DLL
			DisableThreadLibraryCalls( hModule );

			// Only hook the APIs if this is the Everquest proess.
			GetModuleFileName( GetModuleHandle( NULL ), processName, sizeof(processName) );
			PathStripPath( processName );
			PathRemoveExtension(processName);
			//_strlwr_s(processName);

			MEMORY_BASIC_INFORMATION mbi;
			static int dummy;
			VirtualQuery( &dummy, &mbi, sizeof(mbi) );

			GetModuleFileName((HMODULE)mbi.AllocationBase,dllName,dllSize);
			PathStripPath  (dllName);

//			ReadRegistryConfig(processName, dllName, filterList, actionDict);	

			GetModuleFileName( GetModuleHandle( NULL ), processInternalName, sizeof(processInternalName) );
			PathStripPath( processInternalName );

//			firstM = true;			
			memset (lastOpenKeyPath,0,1024*sizeof(char));
			HookCalls(true);

			
			
			break;

		}		
		case DLL_PROCESS_DETACH:
		{
		    hDLL = hModule;

			// We don't need thread notifications for what we're doing.  Thus, get
			// rid of them, thereby eliminating some of the overhead of this DLL
			DisableThreadLibraryCalls( hModule );			

			HookCalls(false);

			
			break;			
		}
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
			break;
	}
	return TRUE;  
}


// This segment must be defined as SHARED in the .DEF
#pragma data_seg (".HookSection")		
// Shared instance for all processes.
HHOOK hHook = NULL;	
#pragma data_seg ()

TEST_SBIE_API LRESULT CALLBACK HookProc(int nCode, WPARAM wParam, LPARAM lParam) 
{
    return CallNextHookEx( hHook, nCode, wParam, lParam); 
}

TEST_SBIE_API LRESULT CALLBACK HookMouse(int nCode, WPARAM wParam, LPARAM lParam)
{      
    return CallNextHookEx(NULL, nCode, wParam, lParam); 
}

//TESTDLL_API 
void InstallHook()
{
#ifdef SHOWOUTPUTDEBUGSTRING
    OutputDebugString( "TESTDLL hook installed.\n" );
#endif
    hHook = SetWindowsHookEx( WH_CBT, HookProc, hDLL, 0 ); 
}

//TESTDLL_API 
void RemoveHook()
{
#ifdef SHOWOUTPUTDEBUGSTRING
    OutputDebugString( "TESTDLL hook removed.\n" );
#endif
    UnhookWindowsHookEx( hHook );
}


