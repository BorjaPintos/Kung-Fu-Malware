//#include "ntddk.h"

#include <Ntifs.h>
#include <ntddk.h>
#include "PEStruct.h"

//---------------------------------------------------------------------------
//
// Defines
//  
//---------------------------------------------------------------------------
#define FILE_DEVICE_UNKNOWN             0x00000022
#define IOCTL_UNKNOWN_BASE              FILE_DEVICE_UNKNOWN
#define IOCTL_NTPROCDRV_LOADDLL		    CTL_CODE(IOCTL_UNKNOWN_BASE, 0x0800, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define DRV_POOL_TAG                    "1gaT"
#define STATUS_INVALID_KERNEL_INFO_VERSION 1000
//---------------------------------------------------------------------------
//
// Forward declaration
//  
//---------------------------------------------------------------------------

// OS Dependant data
DYNAMIC_DATA dynData;


void UnloadDriver(PDRIVER_OBJECT DriverObject);


NTSTATUS DispatchCreateClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS DispatchIoctl(	IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

//
// process structure callbacks
//  
VOID ProcessCallback(IN HANDLE  hParentId, IN HANDLE  hProcessId, IN BOOLEAN bCreate);

//BinaryMapping callback
VOID DllMapCallback (IN PUNICODE_STRING FullImageName, IN HANDLE ProcessId, IN PIMAGE_INFO ImageInfo);


UCHAR* PsGetProcessImageFileName(PEPROCESS Process); 
NTKERNELAPI PPEB NTAPI PsGetProcessPeb( IN PEPROCESS Process );
//NTKERNELAPI PVOID NTAPI PsGetProcessWow64Process( IN PEPROCESS Process );
NTKERNELAPI BOOLEAN NTAPI PsIsProtectedProcess( IN PEPROCESS Process );
NTSTATUS NTAPI ZwCreateThreadEx(
    OUT PHANDLE hThread,
    IN ACCESS_MASK DesiredAccess,
    IN PVOID ObjectAttributes,
    IN HANDLE ProcessHandle,
    IN PVOID lpStartAddress,
    IN PVOID lpParameter,
    IN ULONG Flags,
    IN SIZE_T StackZeroBits,
    IN SIZE_T SizeOfStackCommit,
    IN SIZE_T SizeOfStackReserve,
    IN PNT_PROC_THREAD_ATTRIBUTE_LIST AttributeList
    );
	
NTSYSAPI NTSTATUS NTAPI ZwQueryInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI NTSTATUS NTAPI ZwQuerySystemInformation(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL 
    );
NTSYSCALLAPI NTSTATUS NTAPI NtCreateThreadEx (
    OUT PHANDLE hThread,
	IN ACCESS_MASK DesiredAccess,
	IN PVOID ObjectAttributes,
	IN HANDLE ProcessHandle,
	IN PVOID lpStartAddress,
	IN PVOID lpParameter,
	IN ULONG Flags,
	IN SIZE_T StackZeroBits,
	IN SIZE_T SizeOfStackCommit,
	IN SIZE_T SizeOfStackReserve,
	OUT PVOID lpBytesBuffer
);

NTSYSAPI PIMAGE_NT_HEADERS NTAPI RtlImageNtHeader( PVOID Base );
//
// Structure for process callback information
//
typedef struct _LDR_DATA_TABLE_ENTRY 
{
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    LIST_ENTRY HashLinks;
    ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;


typedef struct _PEB_LDR_DATA 
{
    ULONG Length;
    UCHAR Initialized;
    PVOID SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _PEB 
{
    UCHAR InheritedAddressSpace;
    UCHAR ReadImageFileExecOptions;
    UCHAR BeingDebugged;
    UCHAR BitField;
    PVOID Mutant;
    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    PVOID ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PVOID FastPebLock;
    PVOID AtlThunkSListPtr;
    PVOID IFEOKey;
    PVOID CrossProcessFlags;
    PVOID UserSharedInfoPtr;
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    PVOID ApiSetMap;
	ULONG TlsExpansionCounter;
	PVOID TlsBitmap;
	ULONG TlsBitmapBits1;
	ULONG TlsBitmapBits2;
	PVOID ReadOnlySharedMemoryBase;
	PVOID HotpatchInformation;
	PVOID * ReadOnlyStaticServerData;
	PVOID AnsiCodePageData;
	PVOID OemCodePageData;
	PVOID UnicodeCaseTableData;
	ULONG NumberOfProcessors;
} PEB, *PPEB;

/*typedef struct _CallbackInfo
{
    HANDLE  hProcessId;
    PVOID   loadLibraryAddress;
}CALLBACK_INFO, *PCALLBACK_INFO;
*/
//
// Private storage 
//
/*typedef struct _DEVICE_EXTENSION 
{
    PDEVICE_OBJECT DeviceObject;
    HANDLE  hProcessHandle;
    PKEVENT ProcessEvent;

    HANDLE  hPParentId;
    HANDLE  hPProcessId;
    BOOLEAN bPCreate;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;
*/

PSYSTEM_SERVICE_DESCRIPTOR_TABLE g_SSDT = NULL;
PVOID g_KernelBase = NULL;
ULONG g_KernelSize = 0;

/// <summary>
/// Get ntoskrnl base address
/// </summary>
/// <param name="pSize">Size of module</param>
/// <returns>Found address, NULL if not found</returns>
PVOID GetKernelBase( OUT PULONG pSize )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG bytes = 0;
    PRTL_PROCESS_MODULES pMods = NULL;
    PVOID checkPtr = NULL;
    UNICODE_STRING routineName;
	ULONG i;
	
    // Already found
    if (g_KernelBase != NULL)
    {
        if (pSize)
            *pSize = g_KernelSize;
        return g_KernelBase;
    }

	RtlInitUnicodeString( &routineName, L"NtCreateThreadEx" );
	checkPtr = MmGetSystemRoutineAddress( &routineName );
    if (checkPtr == NULL)
	{
		DbgPrint("NOT FOUND NewThread Rutine");
	}
	else
	{
		DbgPrint("FOUND NewThread Rutine");
	}
	
    RtlInitUnicodeString( &routineName, L"NtOpenFile" );

    checkPtr = MmGetSystemRoutineAddress( &routineName );
    if (checkPtr == NULL)
        return NULL;
	
    // Protect from UserMode AV
    __try
    {
        status = ZwQuerySystemInformation( SystemModuleInformation, 0, bytes, &bytes );
        if (bytes == 0)
        {
            DbgPrint( " Invalid SystemModuleInformation size\n" );
            return NULL;
        }

        pMods = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag( NonPagedPool, bytes, DRV_POOL_TAG );
        RtlZeroMemory( pMods, bytes );

        status = ZwQuerySystemInformation( SystemModuleInformation, pMods, bytes, &bytes );

        if (NT_SUCCESS( status ))
        {
            PRTL_PROCESS_MODULE_INFORMATION pMod = pMods->Modules;

            for (i = 0; i < pMods->NumberOfModules; i++)
            {
                // System routine is inside module
                if (checkPtr >= pMod[i].ImageBase &&
                     checkPtr < (PVOID)((PUCHAR)pMod[i].ImageBase + pMod[i].ImageSize))
                {
                    g_KernelBase = pMod[i].ImageBase;
                    g_KernelSize = pMod[i].ImageSize;
                    if (pSize)
                        *pSize = g_KernelSize;
                    break;
                }
            }
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DbgPrint( "Exception\n" );
    }

    if (pMods)
        ExFreePoolWithTag( pMods, DRV_POOL_TAG );

    return g_KernelBase;
}


/// <summary>
/// Search for pattern
/// </summary>
/// <param name="pattern">Pattern to search for</param>
/// <param name="wildcard">Used wildcard</param>
/// <param name="len">Pattern length</param>
/// <param name="base">Base address for searching</param>
/// <param name="size">Address range to search in</param>
/// <param name="ppFound">Found location</param>
/// <returns>Status code</returns>
NTSTATUS SearchPattern( IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN const VOID* base, IN ULONG_PTR size, OUT PVOID* ppFound )
{
	ULONG_PTR i, j;
    ASSERT( ppFound != NULL && pattern != NULL && base != NULL );
    if (ppFound == NULL || pattern == NULL || base == NULL)
	{
		DbgPrint("SearchPatern Invalid Parameter");
        return STATUS_INVALID_PARAMETER;
	}
    __try
    {
		DbgPrint ("size %d len %d",size,len);
        for (i = 0; i < size - len; i++)
        {
            BOOLEAN found = TRUE;
            for (j = 0; j < len; j++)
            {
				
                if (pattern[j] != wildcard && pattern[j] != ((PCUCHAR)base)[i + j])
                {
                    found = FALSE;
                    break;
                }
            }

            if (found != FALSE)
            {
                *ppFound = (PUCHAR)base + i;
                return STATUS_SUCCESS;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return STATUS_UNHANDLED_EXCEPTION;
    }

    return STATUS_NOT_FOUND;
}
/*#pragma pack(1)
typedef struct ServiceDescriptorEntry {
        unsigned int *ServiceTableBase;
        unsigned int *ServiceCounterTableBase; //Used only in checked build
        unsigned int NumberOfServices;
        unsigned char *ParamTableBase;
} ServiceDescriptorTableEntry_t, *PServiceDescriptorTableEntry_t;
#pragma pack()*/

__declspec(dllimport) SYSTEM_SERVICE_DESCRIPTOR_TABLE KeServiceDescriptorTable;
#define SYSTEMSERVICE(_function) KeServiceDescriptorTable.ServiceTableBase[ *(PULONG)((PUCHAR)_function+1)]
#define SYSTEMNUMBER (_index) KeServiceDescriptorTable.ServiceTableBase []

/// <summary>
/// Gets SSDT base - KiServiceTable
/// </summary>
/// <returns>SSDT base, NULL if not found</returns>
PSYSTEM_SERVICE_DESCRIPTOR_TABLE GetSSDTBase()
{
	NTSTATUS status;
	PIMAGE_NT_HEADERS pHdr;
	PIMAGE_SECTION_HEADER pFirstSec;
	PIMAGE_SECTION_HEADER pSec;
	UCHAR pattern[] = "\x4c\x8d\x15\xcc\xcc\xcc\xcc\x4c\x8d\x1d\xcc\xcc\xcc\xcc\xf7";
	
    PUCHAR ntosBase = GetKernelBase( NULL );

    // Already found
    if (g_SSDT != NULL)
        return g_SSDT;

    if (!ntosBase)
        return NULL;
    
    pHdr = RtlImageNtHeader( ntosBase );
    pFirstSec = (PIMAGE_SECTION_HEADER)(pHdr + 1);
    for (pSec = pFirstSec; pSec < pFirstSec + pHdr->FileHeader.NumberOfSections; pSec++)
    {
        // Non-paged, non-discardable, readable sections
        // Probably still not fool-proof enough...
        if (pSec->Characteristics & IMAGE_SCN_MEM_NOT_PAGED &&
            pSec->Characteristics & IMAGE_SCN_MEM_EXECUTE &&
            !(pSec->Characteristics & IMAGE_SCN_MEM_DISCARDABLE) &&
            (*(PULONG)pSec->Name != 'TINI') &&
            (*(PULONG)pSec->Name != 'EGAP'))
        {
            PVOID pFound = NULL;
			DbgPrint("Searching pattern");
            // KiSystemServiceRepeat pattern
            
            status = SearchPattern( pattern, 0xCC, sizeof( pattern ) - 1, ntosBase + pSec->VirtualAddress, pSec->Misc.VirtualSize, &pFound );
            if (NT_SUCCESS( status ))
            {
                g_SSDT = (PSYSTEM_SERVICE_DESCRIPTOR_TABLE)((PUCHAR)pFound + *(PULONG)((PUCHAR)pFound + 3) + 7);
                //DPRINT( "BlackBone: %s: KeSystemServiceDescriptorTable = 0x%p\n", __FUNCTION__, g_SSDT );
                return g_SSDT;
            }
        }
    } 
    //return &KeServiceDescriptorTable;
    return NULL;
}

PVOID GetSSDTEntry( IN ULONG index )
{
    ULONG size = 0;
    PSYSTEM_SERVICE_DESCRIPTOR_TABLE pSSDT = GetSSDTBase();
    PVOID pBase = GetKernelBase( &size );

    if (pSSDT && pBase)
    {
		DbgPrint("SSDT and pBase found");
        // Index range check
        if (index > pSSDT->NumberOfServices)
            return NULL;

        return (PUCHAR)pSSDT->ServiceTableBase + (((PLONG)pSSDT->ServiceTableBase)[index] >> 4);
    }
	else
	{
		if (!pSSDT)
			DbgPrint("SSDT NOT found");
		if (!pBase)
			DbgPrint("pBase NOT found");
	}

    return NULL;
}


NTSTATUS  NTAPI ZwCreateThreadEx( OUT PHANDLE hThread, IN ACCESS_MASK DesiredAccess, IN PVOID ObjectAttributes, IN HANDLE ProcessHandle, IN PVOID lpStartAddress, IN PVOID lpParameter, IN ULONG Flags, IN SIZE_T StackZeroBits, IN SIZE_T SizeOfStackCommit, IN SIZE_T SizeOfStackReserve, IN PNT_PROC_THREAD_ATTRIBUTE_LIST AttributeList )
{
	PUCHAR pPrevMode;
	UCHAR prevMode;
	
    NTSTATUS status = STATUS_SUCCESS;

    fnNtCreateThreadEx pNtCreateThreadEx = (fnNtCreateThreadEx)(ULONG_PTR)GetSSDTEntry( dynData.NtCreateThdIndex );
	/*if (!pNtCreateThreadEx)
	{
		pNtCreateThreadEx = (fnNtCreateThreadEx) (SYSTEMSERVICE(NtCreateThreadEx));
	}*/
    if (pNtCreateThreadEx)
    {
        //
        // If previous mode is UserMode, addresses passed into ZwCreateThreadEx must be in user-mode space
        // Switching to KernelMode allows usage of kernel-mode addresses
        //
        pPrevMode = (PUCHAR)PsGetCurrentThread() + dynData.PrevMode;
        prevMode = *pPrevMode;
        *pPrevMode = KernelMode;

        status = pNtCreateThreadEx(
            hThread, DesiredAccess, ObjectAttributes,
            ProcessHandle, lpStartAddress, lpParameter,
            Flags, StackZeroBits, SizeOfStackCommit,
            SizeOfStackReserve, AttributeList
            );

        *pPrevMode = prevMode;
    }
    else
	{
		DbgPrint("NtCreateThreadEx pointer not found");
        status = STATUS_NOT_FOUND;
	}
    return status;
}


/// <summary>
/// Get kernel build number
/// </summary>
/// <param name="pBuildNO">Build number.</param>
/// <returns>Status code</returns>
NTSTATUS GetBuildNO( OUT PULONG pBuildNo )
{
	NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING strRegKey = { 0 };
    UNICODE_STRING strRegValue = { 0 };
    UNICODE_STRING strVerVal = { 0 };
    HANDLE hKey = NULL;
    OBJECT_ATTRIBUTES keyAttr = { 0 };
	PWCHAR pData; 
	ULONG i,j;
	
    ASSERT( pBuildNo != NULL );
    if (pBuildNo == 0)
        return STATUS_INVALID_PARAMETER;

   
    RtlInitUnicodeString( &strRegKey, L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion" );
    RtlInitUnicodeString( &strRegValue, L"BuildLabEx" );

    InitializeObjectAttributes( &keyAttr, &strRegKey, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL );

    status = ZwOpenKey( &hKey, KEY_READ, &keyAttr );
    if (NT_SUCCESS( status ))
    {
        PKEY_VALUE_FULL_INFORMATION pValueInfo = ExAllocatePoolWithTag( PagedPool, 0x1000, DRV_POOL_TAG );
        ULONG bytes = 0;

        if (pValueInfo)
        {
            status = ZwQueryValueKey( hKey, &strRegValue, KeyValueFullInformation, pValueInfo, 0x1000, &bytes );
            if (NT_SUCCESS( status ))
            {
                pData = (PWCHAR)((PUCHAR)pValueInfo->Name + pValueInfo->NameLength);
                for (i = 0; i < pValueInfo->DataLength; i++)
                {
                    if (pData[i] == L'.')
                    {
                        for (j = i + 1; j < pValueInfo->DataLength; j++)
                        {
                            if (pData[j] == L'.')
                            {
                                strVerVal.Buffer = &pData[i] + 1;
                                strVerVal.Length = strVerVal.MaximumLength = (USHORT)((j - i) * sizeof( WCHAR ));
                                status = RtlUnicodeStringToInteger( &strVerVal, 10, pBuildNo );

                                goto skip1;
                            }
                        }
                    }
                }

            skip1:;
            }

            ExFreePoolWithTag( pValueInfo, DRV_POOL_TAG );
        }
        else
            status = STATUS_NO_MEMORY;

        ZwClose( hKey );
    }
    else
        DbgPrint( "ZwOpenKey failed with status 0x%X\n", status );

    return status;

}

/// <summary>
/// Initialize dynamic data.
/// </summary>
/// <param name="pData">Data to initialize</param>
/// <returns>Status code</returns>
NTSTATUS InitDynamicData( IN OUT PDYNAMIC_DATA pData )
{
    NTSTATUS status = STATUS_SUCCESS;
    RTL_OSVERSIONINFOEXW verInfo = { 0 };
    ULONG buildNo = 0;

    const ULONG w7Build  = 18798;
    const ULONG w8Build  = 17328;
    const ULONG w10Build = 16412;

    UNREFERENCED_PARAMETER( w7Build );
    UNREFERENCED_PARAMETER( w8Build );
    UNREFERENCED_PARAMETER( w10Build );

    if (pData == NULL)
        return STATUS_INVALID_ADDRESS;

    RtlZeroMemory( pData, sizeof( DYNAMIC_DATA ) );

    verInfo.dwOSVersionInfoSize = sizeof( verInfo );
    status = RtlGetVersion( (PRTL_OSVERSIONINFOW)&verInfo );

    if (status == STATUS_SUCCESS)
    {
        ULONG ver_short = (verInfo.dwMajorVersion << 8) | (verInfo.dwMinorVersion << 4) | verInfo.wServicePackMajor;
        pData->ver = (WinVer)ver_short;

        // Get kernel build number
        status = GetBuildNO( &buildNo );

        // Validate current driver version
        pData->correctBuild = TRUE;
    #if defined(_WIN7_)
        if (ver_short != WINVER_7 && ver_short != WINVER_7_SP1)
            return STATUS_NOT_SUPPORTED;
        if(ver_short == WINVER_7_SP1 && buildNo != w7Build)
            pData->correctBuild = FALSE;
    #elif defined(_WIN8_)
        if (ver_short != WINVER_8)
            return STATUS_NOT_SUPPORTED;
    #elif defined (_WIN81_)
        if (ver_short != WINVER_81)
            return STATUS_NOT_SUPPORTED;
        if (buildNo != w8Build)
            pData->correctBuild = FALSE;
    #elif defined (_WIN10_)
        if (ver_short != WINVER_10)           
            return STATUS_NOT_SUPPORTED;
        if (buildNo != w10Build)
            pData->correctBuild = FALSE;
    #endif

        DbgPrint( 
            "OS version %d.%d.%d.%d.%d - 0x%x. Build supported: %s\n",
            verInfo.dwMajorVersion,
            verInfo.dwMinorVersion,
            verInfo.dwBuildNumber,
            verInfo.wServicePackMajor,
            buildNo,
            ver_short,
            pData->correctBuild ? "true" : "false"
            );

        switch (ver_short)
        {
                // Windows 7
                // Windows 7 SP1, build 18798
            case WINVER_7:
            case WINVER_7_SP1:
                pData->KExecOpt         = 0x0D2;
                pData->Protection       = 0x43C;  // Bitfield, bit index - 0xB
                pData->ObjTable         = 0x200;
                pData->VadRoot          = 0x448;
                pData->NtProtectIndex   = 0x04D;
                pData->NtCreateThdIndex = 0x0A5;
                pData->NtTermThdIndex   = 0x50;
                pData->PrevMode         = 0x1F6;
                pData->ExitStatus       = 0x380;
                pData->MiAllocPage      = (ver_short == WINVER_7_SP1) ? 0 : 0;
                pData->ExRemoveTable    = (ver_short == WINVER_7_SP1) ? 0x32A870 : 0x32D404;
                break;

                // Windows 8
            case WINVER_8:
                pData->KExecOpt         = 0x1B7;
                pData->Protection       = 0x648;
                pData->ObjTable         = 0x408;
                pData->VadRoot          = 0x590;
                pData->NtProtectIndex   = 0x04E;
                pData->NtCreateThdIndex = 0x0AF;
                pData->NtTermThdIndex   = 0x51;
                pData->PrevMode         = 0x232;
                pData->ExitStatus       = 0x450;
                pData->MiAllocPage      = 0x3AF374;
                pData->ExRemoveTable    = 0x487518;
                break;

                // Windows 8.1, build 17328
            case WINVER_81:
                pData->KExecOpt         = 0x1B7;
                pData->Protection       = 0x67A;
                pData->ObjTable         = 0x408;
                pData->VadRoot          = 0x5D8;
                pData->NtCreateThdIndex = 0xB0;
                pData->NtTermThdIndex   = 0x52;
                pData->PrevMode         = 0x232;
                pData->ExitStatus       = 0x6D8;
                pData->MiAllocPage      = 0;
                pData->ExRemoveTable    = 0x432A88; // 0x38E320;
                break;

                // Windows 10, build 16412
            case WINVER_10:
                pData->KExecOpt         = 0x1BF;
                pData->Protection       = 0x6AA;
                pData->ObjTable         = 0x418;
                pData->VadRoot          = 0x608;
                pData->NtCreateThdIndex = 0xB3;
                pData->NtTermThdIndex   = 0x53;
                pData->PrevMode         = 0x232;
                pData->ExitStatus       = 0x6E0;
                pData->MiAllocPage      = 0;
                pData->ExRemoveTable    = 0x4C36AC;
                break;

            default:
                break;
        }

        return (pData->VadRoot != 0 ? status : STATUS_INVALID_KERNEL_INFO_VERSION);
    }

    return status;
}

//ULONG ApcStateOffset;
//
// The main entry point of the driver module
//




//
typedef struct _DEVICE_EXTENSION 
{
    PDEVICE_OBJECT DeviceObject;
    HANDLE  hProcessHandle;
    PKEVENT ProcessEvent;

    HANDLE  hProcessId;
	PVOID   LoadLibraryAddress;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


//PDEVICE_OBJECT g_pDeviceObject;

typedef struct _CALLBACK_INFO 
{   
    HANDLE  hProcessId;
	PVOID   LoadLibraryAddress;
} CALLBACK_INFO, *PCALLBACK_INFO;
//
// Read Request Queue
//
LIST_ENTRY ReadRequestQueue,PIDQueue;
//
// Read Request Queue Lock
//
FAST_MUTEX ReadRequestQueueLock,PIDQueueLock;
typedef struct _OSR_COMM_DATA_REQUEST {

  //
  // This is used to thread the requests onto a data request queue
  //
  LIST_ENTRY ListEntry;
 
  PIRP Irp;
} OSR_COMM_DATA_REQUEST, *POSR_COMM_DATA_REQUEST;

typedef struct _PID_ELEMENT {
	LIST_ENTRY ListEntry;
	HANDLE PID;
	PVOID pAddr;
} PID_ELEMENT, *PPID_ELEMENT;


VOID EncolarRespuesta(HANDLE PID, PVOID pAddr)
{
	PPID_ELEMENT pidElement;
	pidElement = (PPID_ELEMENT) ExAllocatePoolWithTag(PagedPool, sizeof(PID_ELEMENT), DRV_POOL_TAG);
    if (!pidElement) {
		DbgPrint ("Recursos insuficientes, Perdido PID %d", PID);	
		return;
	}
	RtlZeroMemory(pidElement, sizeof(PID_ELEMENT));
	pidElement->PID = PID;
	pidElement->pAddr = pAddr;
	ExAcquireFastMutex(&PIDQueueLock);
	InsertTailList(&PIDQueue, &pidElement->ListEntry);
	ExReleaseFastMutex(&PIDQueueLock);
	DbgPrint("PID Encolado %d", pidElement->PID); 
}

void FillReadBufferWithPID(PCALLBACK_INFO pCBInfo)
{
	PLIST_ENTRY listEntry;
	PLIST_ENTRY nextListEntry;
	PPID_ELEMENT pendingPID;
	//
	// Lock the list
	//
	
	ExAcquireFastMutex(&PIDQueueLock);
	if (IsListEmpty(&PIDQueue))
	{	
		ExReleaseFastMutex(&PIDQueueLock); //NO HAY PIDs que comunicar
		//
		// Done!
		//
		return;
	}
	//
	// Getting first pending PID
	//
	for (listEntry = PIDQueue.Flink;
       listEntry != &PIDQueue;
       listEntry = nextListEntry) {
    //
    // Set up the next list entry first.  Thus, even if we delete the
    // list entry from the queue, we can skip to the next entry
    //
		nextListEntry = listEntry->Flink;
    //
    // Extract the data request from the list entry
    //
		pendingPID = CONTAINING_RECORD(listEntry, PID_ELEMENT, ListEntry);
		DbgPrint("Getting Pending PID %d",pendingPID->PID);
		
		//
		// We need to remove this entry from the queue
		//
		RemoveEntryList(listEntry);
		//
		// COPY DATA TO IN PARAMETER
		pCBInfo->hProcessId 		= pendingPID->PID;
		pCBInfo->LoadLibraryAddress	= pendingPID->pAddr;
		ExFreePool(pendingPID);
		break;

  }
  //
  // Unlock the list
  //
  ExReleaseFastMutex(&PIDQueueLock);
  //
  // Done!
  //
  return;

}

NTSTATUS DispatchRead(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	
    PIO_STACK_LOCATION pIoStackIrp = NULL;
	ULONG dwDataRead = 0;
    ULONG dwDataSize; 
	NTSTATUS NtStatus = STATUS_BUFFER_TOO_SMALL;
    PCALLBACK_INFO pReadDataBuffer;

	
	dwDataSize = sizeof(CALLBACK_INFO);	
    //DbgPrint("DispatchRead Called");
    
    /*
     * Each time the IRP is passed down the driver stack a new stack location is added
     * specifying certain parameters for the IRP to the driver.
     */
    pIoStackIrp = IoGetCurrentIrpStackLocation(Irp);
    
    if(pIoStackIrp)
    {
        pReadDataBuffer = (PCALLBACK_INFO)Irp->AssociatedIrp.SystemBuffer;
		//DbgPrint ("Buffer read length %d systemBuffer %d ", pIoStackIrp->Parameters.Read.Length,Irp->AssociatedIrp.SystemBuffer);
        if(pReadDataBuffer) //&& pIoStackIrp->Parameters.Read.Length >= dwDataSize)
        {                             
			//DbgPrint("Length sizeof:%d IRP:%d",dwDataSize,pIoStackIrp->Parameters.Read.Length);
			if (pIoStackIrp->Parameters.Read.Length >= dwDataSize) {
				/*
				 * We use "RtlCopyMemory" in the kernel instead of memcpy.
				 * RtlCopyMemory *IS* memcpy, however it's best to use the
				 * wrapper in case this changes in the future.
				 */
				//RtlCopyMemory(pReadDataBuffer, pReturnData, dwDataSize);
				pReadDataBuffer->hProcessId = 0;
				pReadDataBuffer->LoadLibraryAddress = 0x00000000;
				
				FillReadBufferWithPID(pReadDataBuffer);
				
				
				
				dwDataRead = dwDataSize;
				NtStatus = STATUS_SUCCESS;
			}
        }
	
    }
    
   
    Irp->IoStatus.Status = NtStatus;
    Irp->IoStatus.Information = dwDataRead;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return NtStatus;
}

BOOLEAN EstaVaciaListaPIDsPendientes()
{
	BOOLEAN result; 
	
	ExAcquireFastMutex(&PIDQueueLock);
	result = IsListEmpty(&PIDQueue);
	ExReleaseFastMutex(&PIDQueueLock); 
	
	return result;
}

NTSTATUS DispatchWrite(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	POSR_COMM_DATA_REQUEST  dataRequest;
	NTSTATUS status;
	
	DbgPrint("Receiving IRP");
	
	if (!EstaVaciaListaPIDsPendientes()) //SI HAY PIDs pendientes no dejamos la IRP pendiente, la terminamos y que se llame a leer
	{
		status = STATUS_SUCCESS;   
		Irp->IoStatus.Status = status;
		Irp->IoStatus.Information = 0;
		IoCompleteRequest(Irp, IO_NO_INCREMENT);			
		DbgPrint("Hay PIDs pendientes, no se deja IRP pendiente");
        return status;
	}
	
	
	dataRequest = (POSR_COMM_DATA_REQUEST) ExAllocatePoolWithTag(PagedPool, sizeof(OSR_COMM_DATA_REQUEST), DRV_POOL_TAG);
    if (!dataRequest) {
            //
            // Complete the request, indicating that the operation failed
            //
        status = STATUS_INSUFFICIENT_RESOURCES;   
		Irp->IoStatus.Status = status;
		Irp->IoStatus.Information = 0;
		IoCompleteRequest(Irp, IO_NO_INCREMENT);			
		DbgPrint("Insuficientes recursos, cancelamos IRP");
        return status;
    }
     
	//Enqueue request
	IoMarkIrpPending(Irp);
    status = STATUS_PENDING;
	
    RtlZeroMemory(dataRequest, sizeof(OSR_COMM_DATA_REQUEST));
	dataRequest->Irp = Irp;
	
	ExAcquireFastMutex(&ReadRequestQueueLock);
	InsertTailList(&ReadRequestQueue, &dataRequest->ListEntry);
	//IoSetCancelRoutine(Irp,CancelPendingIrp);
	ExReleaseFastMutex(&ReadRequestQueueLock);
	DbgPrint("IRP Encolada");
	return status;
}

static VOID CancelPendingRequestList()
{
  PLIST_ENTRY listEntry;
  PLIST_ENTRY nextListEntry;
  POSR_COMM_DATA_REQUEST dataRequest;
  //
  // Lock the list
  //
	DbgPrint("Canceling all pending IRP");
  ExAcquireFastMutex(&ReadRequestQueueLock);
  //
  // Walk the list
  //
  for (listEntry = ReadRequestQueue.Flink;
       listEntry != &ReadRequestQueue;
       listEntry = nextListEntry) {
    //
    // Set up the next list entry first.  Thus, even if we delete the
    // list entry from the queue, we can skip to the next entry
    //
    nextListEntry = listEntry->Flink;
    //
    // Extract the data request from the list entry
    //
    dataRequest = CONTAINING_RECORD(listEntry, OSR_COMM_DATA_REQUEST, ListEntry);
    
	
    if (dataRequest->Irp){
      //
      // We need to remove this entry from the queue
      //
	  RemoveEntryList(listEntry);
      //
      // Cancel this IRP
      dataRequest->Irp->IoStatus.Status = STATUS_CANCELLED;
      dataRequest->Irp->IoStatus.Information = 0;
      IoCompleteRequest(dataRequest->Irp, IO_NO_INCREMENT);
      //
      // Free this data request
      //
	  DbgPrint("Canceled IRP");
      ExFreePool(dataRequest);
    }
  }
  //
  // Unlock the list
  //
  ExReleaseFastMutex(&ReadRequestQueueLock);
  //
  // Done!
  //
  return;
}


NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath	)
{
    NTSTATUS        ntStatus,status;
    UNICODE_STRING  uszDriverString;
    UNICODE_STRING  uszDeviceString;
    UNICODE_STRING  uszProcessEventString;
	
	PEPROCESS Process;
    PETHREAD Thread;
    PKAPC_STATE ApcState;
	PULONG ptr;
	ULONG i;

    PDEVICE_OBJECT    pDeviceObject;
    PDEVICE_EXTENSION extension;
    
	
	// Get OS Dependant offsets
    status = InitDynamicData( &dynData );
    if (!NT_SUCCESS( status ))
    {
        DbgPrint( "Unsupported OS version. Aborting\n" );
        return status;
    }
	
    DbgPrint("Driver Loading");
	// Point uszDriverString at the driver name
    RtlInitUnicodeString(&uszDriverString, L"\\Device\\ProcDebugger");

    // Create and initialize device object
    ntStatus = IoCreateDevice(DriverObject,
                                sizeof(DEVICE_EXTENSION),
                                &uszDriverString,
                                FILE_DEVICE_UNKNOWN,
                                0,
                                FALSE,
                                &pDeviceObject
		                        );
    if(ntStatus != STATUS_SUCCESS)
        return ntStatus;
    
	// Assign extension variable
    extension = pDeviceObject->DeviceExtension;
    
	// Point uszDeviceString at the device name
    RtlInitUnicodeString(&uszDeviceString, L"\\DosDevices\\ProcDebugger");
    
	// Create symbolic link to the user-visible name
    ntStatus = IoCreateSymbolicLink(&uszDeviceString, &uszDriverString);

    if(ntStatus != STATUS_SUCCESS)
    {
        // Delete device object if not successful
        //IoDeleteDevice(pDeviceObject);
        return ntStatus;
    }
    DbgPrint("Simlynk created");
    // Assign global pointer to the device object for use by the callback functions
    //g_pDeviceObject = pDeviceObject;
	
	InitializeListHead(&ReadRequestQueue);
	ExInitializeFastMutex(&ReadRequestQueueLock);
	InitializeListHead(&PIDQueue);
	ExInitializeFastMutex(&PIDQueueLock);
    
	// Load structure to point to IRP handlers
    DriverObject->DriverUnload                         = UnloadDriver;
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = DispatchCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = DispatchCreateClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchIoctl;
	DriverObject->MajorFunction[IRP_MJ_WRITE] 		   = DispatchWrite;
	DriverObject->MajorFunction[IRP_MJ_READ] 		   = DispatchRead;

	pDeviceObject->Flags |= DO_BUFFERED_IO;
	
    // Create event for user-mode processes to monitor
   // RtlInitUnicodeString(&uszProcessEventString, L"\\BaseNamedObjects\\ProcDebuggerProcessEvent");
    //extension->ProcessEvent = IoCreateNotificationEvent (&uszProcessEventString, &extension->hProcessHandle);

    // Clear it out
    //KeClearEvent(extension->ProcessEvent);
 
    // Set up callback routines
    ntStatus = PsSetCreateProcessNotifyRoutine(ProcessCallback, FALSE);
    DbgPrint("Process Callback set");
	ntStatus = PsSetLoadImageNotifyRoutine(DllMapCallback);
	DbgPrint("DllMap Callback set");
	
	/*Process=PsGetCurrentProcess();
    Thread=PsGetCurrentThread();
 
    ptr=(PULONG)Thread;
 
    // Locate the ApcState structure
 
    for(i=0;i<512;i++)
    {
        if(ptr[i]==(ULONG)Process)
        {
            ApcState=CONTAINING_RECORD(&ptr[i],KAPC_STATE,Process); // Get the actual address of KAPC_STATE
            ApcStateOffset=(ULONG)ApcState-(ULONG)Thread; // Calculate the offset of the ApcState structure
 
            break;
        }
    }*/
	
    // Return success
    return ntStatus;
}


VOID CancelPendingIRP()
{
	PLIST_ENTRY listEntry;
	PLIST_ENTRY nextListEntry;
	POSR_COMM_DATA_REQUEST dataRequest;
	//
	// Lock the list
	//
	
	ExAcquireFastMutex(&ReadRequestQueueLock);
	if (IsListEmpty(&ReadRequestQueue))
	{	
		ExReleaseFastMutex(&ReadRequestQueueLock);
		//
		// Done!
		//
		return;
	}
	//
	// Remove First Pending IRP
	//
	for (listEntry = ReadRequestQueue.Flink;
       listEntry != &ReadRequestQueue;
       listEntry = nextListEntry) {
    //
    // Set up the next list entry first.  Thus, even if we delete the
    // list entry from the queue, we can skip to the next entry
    //
		nextListEntry = listEntry->Flink;
    //
    // Extract the data request from the list entry
    //
		dataRequest = CONTAINING_RECORD(listEntry, OSR_COMM_DATA_REQUEST, ListEntry);

		if (dataRequest->Irp){
			//
			// We need to remove this entry from the queue
			//
			RemoveEntryList(listEntry);
			//
			// Cancel this IRP
			dataRequest->Irp->IoStatus.Status = STATUS_SUCCESS;
			dataRequest->Irp->IoStatus.Information = 0;
			IoCompleteRequest(dataRequest->Irp, IO_NO_INCREMENT);
			//
			// Free this data request
			//
			DbgPrint("Canceled IRP");
			ExFreePool(dataRequest);
			break;
		}
		else
		{
			RemoveEntryList(listEntry);
			ExFreePool(dataRequest);
		}
  }
  //
  // Unlock the list
  //
  ExReleaseFastMutex(&ReadRequestQueueLock);
  //
  // Done!
  //
  return;

}

//
// Create and close routine
//
NTSTATUS DispatchCreateClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    DbgPrint("DispatchCreateClose called");
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information=0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

PVOID GetDllBaseAddr( IN PPEB pPeb, IN PUNICODE_STRING ModuleName)
{
	PLIST_ENTRY pListEntry;
	PLDR_DATA_TABLE_ENTRY pEntry;
	INT i;
	LARGE_INTEGER time = { 0 };
    
	time.QuadPart = -250ll * 10 * 1000;     // 250 msec.
		
	// Wait for loader a bit
	/*for (i = 0; !pPeb->Ldr && i < 10; i++)
	{
		DbgPrint( "Loader not intialiezd, waiting\n"  );
		KeDelayExecutionThread( KernelMode, TRUE, &time );
	}*/
	
	if ((pPeb!=0) && 
		(pPeb->Ldr!=0) )
	{	
		DbgPrint("Going into Load dll Info");
		for ( pListEntry = pPeb->Ldr->InLoadOrderModuleList.Flink; pListEntry != &pPeb->Ldr->InLoadOrderModuleList; pListEntry = pListEntry->Flink)
		{
			pEntry = CONTAINING_RECORD( pListEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks );
			DbgPrint("%wZ",&pEntry->BaseDllName);
			if (RtlCompareUnicodeString( &pEntry->BaseDllName, ModuleName, TRUE ) == 0)
			{
				DbgPrint("FOUND ntdll");
				return pEntry->DllBase;
			}
		}
	}
	else
	{
		DbgPrint("No Load dll Info");
	}
	return NULL;
}




/// <summary>
/// Enable/disable process protection flag
/// </summary>
/// <param name="pProtection">Request params</param>
/// <returns>Status code</returns>
NTSTATUS ChangeProcessProtection( IN HANDLE   pid, IN BOOLEAN enableState )
{
    NTSTATUS status = STATUS_SUCCESS;
    PEPROCESS pProcess = NULL;

    status = PsLookupProcessByProcessId( pid, &pProcess );
    if (NT_SUCCESS( status ))
    {
        if (dynData.Protection != 0)
        {
            // Win7
            if (dynData.ver <= WINVER_7_SP1)
            {
                if (enableState)
                    *(PULONG)((PUCHAR)pProcess + dynData.Protection) |= 1 << 0xB;
                else
                    *(PULONG)((PUCHAR)pProcess + dynData.Protection) &= ~(1 << 0xB);
            }
            // Win8
            else if (dynData.ver == WINVER_8)
            {
                *((PUCHAR)pProcess + dynData.Protection) = enableState;
            }
            // Win8.1
            else if (dynData.ver >= WINVER_81)
            {
                PS_PROTECTION protBuf = { 0 };

                if (enableState == FALSE)
                {
                    protBuf.Level = 0;
                }
                else
                {
                    protBuf.Flags.Signer = PsProtectedSignerWinTcb;
                    protBuf.Flags.Type = PsProtectedTypeProtected;
                }

                *((PUCHAR)pProcess + dynData.Protection) = protBuf.Level;
            }
            else
                status = STATUS_NOT_SUPPORTED;
        }
        else
        {
            DbgPrint( "Invalid protection flag offset\n" );
            status = STATUS_INVALID_ADDRESS;
        }
    }
    else
        DbgPrint( " PsLookupProcessByProcessId failed with status 0x%X\n", status );

    if (pProcess)
        ObDereferenceObject( pProcess );

    return status;
}


//
PVOID GetModuleExportAddress( IN PVOID pBase, IN PCCHAR name_ord)//, IN PUNICODE_STRING baseName )
{
	PUSHORT pAddressOfOrds; 
	PULONG  pAddressOfNames;
	PULONG  pAddressOfFuncs;
	ULONG i;
	
    PIMAGE_DOS_HEADER pDosHdr = (PIMAGE_DOS_HEADER)pBase;
    PIMAGE_NT_HEADERS32 pNtHdr32 = NULL;
    PIMAGE_EXPORT_DIRECTORY pExport = NULL;
    ULONG expSize = 0;
    ULONG_PTR pAddress = 0;
	

    ASSERT( pBase != NULL );
    if (pBase == NULL)
        return NULL;

    // Protect from UserMode AV
    __try
    {
        // Not a PE file
        if (pDosHdr->e_magic != IMAGE_DOS_SIGNATURE)
            return NULL;

        pNtHdr32 = (PIMAGE_NT_HEADERS32)((PUCHAR)pBase + pDosHdr->e_lfanew);

        // Not a PE file
        if (pNtHdr32->Signature != IMAGE_NT_SIGNATURE)
            return NULL;

        
        pExport = (PIMAGE_EXPORT_DIRECTORY)(pNtHdr32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + (ULONG_PTR)pBase);
        expSize = pNtHdr32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
        

        pAddressOfOrds = (PUSHORT)(pExport->AddressOfNameOrdinals + (ULONG_PTR)pBase);
        pAddressOfNames = (PULONG)(pExport->AddressOfNames + (ULONG_PTR)pBase);
        pAddressOfFuncs = (PULONG)(pExport->AddressOfFunctions + (ULONG_PTR)pBase);

        for (i = 0; i < pExport->NumberOfFunctions; ++i)
        {
            USHORT OrdIndex = 0xFFFF;
            PCHAR  pName = NULL;

            // Find by index
            if ((ULONG_PTR)name_ord <= 0xFFFF)
            {
                OrdIndex = (USHORT)i;
            }
            // Find by name
            else if ((ULONG_PTR)name_ord > 0xFFFF && i < pExport->NumberOfNames)
            {
                pName = (PCHAR)(pAddressOfNames[i] + (ULONG_PTR)pBase);
                OrdIndex = pAddressOfOrds[i];
				//DbgPrint ("Export Name %s", pName);
            }
            // Weird params
            else
                return NULL;

            if (((ULONG_PTR)name_ord <= 0xFFFF && (USHORT)((ULONG_PTR)name_ord) == OrdIndex + pExport->Base) ||
                 ((ULONG_PTR)name_ord > 0xFFFF && strcmp( pName, name_ord ) == 0))
            {
                pAddress = pAddressOfFuncs[OrdIndex] + (ULONG_PTR)pBase;
				
                // Check forwarded export
                /*if (pAddress >= (ULONG_PTR)pExport && pAddress <= (ULONG_PTR)pExport + expSize)
                {
                    WCHAR strbuf[256] = { 0 };
                    ANSI_STRING forwarder = { 0 };
                    ANSI_STRING import = { 0 };

                    UNICODE_STRING uForwarder = { 0 };              
                    ULONG delimIdx = 0;
                    PVOID forwardBase = NULL;
                    PVOID result = NULL;

                    // System image, not supported
                    if (pProcess == NULL)
                        return NULL;

                    RtlInitAnsiString( &forwarder, (PCSZ)pAddress );
                    RtlInitEmptyUnicodeString( &uForwarder, strbuf, sizeof( strbuf ) );

                    RtlAnsiStringToUnicodeString( &uForwarder, &forwarder, FALSE );
                    for (ULONG j = 0; j < uForwarder.Length / sizeof( WCHAR ); j++)
                    {
                        if (uForwarder.Buffer[j] == L'.')
                        {
                            uForwarder.Length = (USHORT)(j * sizeof( WCHAR ));
                            uForwarder.Buffer[j] = L'\0';
                            delimIdx = j;
                            break;
                        }
                    }

                    // Get forward function name/ordinal
                    RtlInitAnsiString( &import, forwarder.Buffer + delimIdx + 1 );
                    RtlAppendUnicodeToString( &uForwarder, L".dll" );

                    //
                    // Check forwarded module
                    //
                    UNICODE_STRING resolved = { 0 };
                    UNICODE_STRING resolvedName = { 0 };
                    BBResolveImagePath( NULL, pProcess, KApiShemaOnly, &uForwarder, baseName, &resolved );
                    BBStripPath( &resolved, &resolvedName );

                    forwardBase = BBGetUserModule( pProcess, &resolvedName, PsGetProcessWow64Process( pProcess ) != NULL );
                    result = BBGetModuleExport( forwardBase, import.Buffer, pProcess, &resolvedName );
                    RtlFreeUnicodeString( &resolved );

                    return result;
                }*/

                break;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DbgPrint( "Exception\n");
    }

    return (PVOID)pAddress;
}


/// <summary>
/// Build injection code for wow64 process
/// Must be running in target process context
/// </summary>
/// <param name="LdrLoadDll">LdrLoadDll address</param>
/// <param name="pPath">Path to the dll</param>
/// <returns>Code pointer. When not needed, it should be freed with ZwFreeVirtualMemory</returns>
PINJECT_BUFFER GetInjectCode( IN PVOID LdrLoadDll, IN PUNICODE_STRING pPath )
{
    NTSTATUS status = STATUS_SUCCESS;
    PINJECT_BUFFER pBuffer = NULL;
    SIZE_T size = PAGE_SIZE;

    // Code
    UCHAR code[] = 
    { 
        0x68, 0, 0, 0, 0,                       // push ModuleHandle            offset +1 
        0x68, 0, 0, 0, 0,                       // push ModuleFileName          offset +6
        0x6A, 0,                                // push Flags  
        0x6A, 0,                                // push PathToFile
        0xE8, 0, 0, 0, 0,                       // call LdrLoadDll              offset +15
        0xBA, 0, 0, 0, 0,                       // mov edx, COMPLETE_OFFSET     offset +20
        0xC7, 0x02, 0x7E, 0x1E, 0x37, 0xC0,     // mov [edx], CALL_COMPLETE     
        0xC2, 0x04, 0x00                        // ret 4
    };

    status = ZwAllocateVirtualMemory( ZwCurrentProcess(), &pBuffer, 0, &size, MEM_COMMIT, PAGE_EXECUTE_READWRITE );
    if (NT_SUCCESS( status ))
    { 
        // Copy path
        PUNICODE_STRING32 pUserPath = &pBuffer->path32;
        pUserPath->Length = pPath->Length;
        pUserPath->MaximumLength = pPath->MaximumLength;
        pUserPath->Buffer = (ULONG)(ULONG_PTR)pBuffer->buffer;

        // Copy path
        memcpy( (PVOID)pUserPath->Buffer, pPath->Buffer, pPath->Length );

        // Copy code
        memcpy( pBuffer, code, sizeof( code ) );

        // Fill stubs
        *(ULONG*)((PUCHAR)pBuffer + 1)  = (ULONG)(ULONG_PTR)&pBuffer->module;
        *(ULONG*)((PUCHAR)pBuffer + 6)  = (ULONG)(ULONG_PTR)pUserPath;
        *(ULONG*)((PUCHAR)pBuffer + 15) = (ULONG)((ULONG_PTR)LdrLoadDll - ((ULONG_PTR)pBuffer + 15) - 5 + 1);
        *(ULONG*)((PUCHAR)pBuffer + 20) = (ULONG)(ULONG_PTR)&pBuffer->complete;

        return pBuffer;
    }

    UNREFERENCED_PARAMETER( pPath );
    return NULL;
}
/// <summary>
/// Create new thread in the target process
/// Must be running in target process context
/// </summary>
/// <param name="pBaseAddress">Thread start address</param>
/// <param name="pParam">Thread argument</param>
/// <param name="flags">Thread creation flags</param>
/// <param name="wait">If set to TRUE - wait for thread completion</param>
/// <param name="pExitStatus">Thread exit status</param>
/// <returns>Status code</returns>
NTSTATUS ExecuteInNewThread(
    IN PVOID pBaseAddress,
    IN PVOID pParam,
    IN ULONG flags,
    IN BOOLEAN wait,
    OUT PNTSTATUS pExitStatus
    )
{
	NTSTATUS status;
    HANDLE hThread = NULL;
    OBJECT_ATTRIBUTES ob = { 0 };

    InitializeObjectAttributes( &ob, NULL, OBJ_KERNEL_HANDLE, NULL, NULL );

    status= ZwCreateThreadEx(
        &hThread, THREAD_QUERY_LIMITED_INFORMATION, &ob,
        PsGetCurrentProcessId(), pBaseAddress, pParam, flags,
        0, 0x1000, 0x100000, NULL
        );

    // Wait for completion
    if (NT_SUCCESS( status ) && wait != FALSE)
    {
        // Force 60 sec timeout
        LARGE_INTEGER timeout = { 0 };
        timeout.QuadPart = -(60ll * 10 * 1000 * 1000);

        status = ZwWaitForSingleObject( hThread, TRUE, &timeout );
        if (NT_SUCCESS( status ))
        {
            THREAD_BASIC_INFORMATION info = { 0 };
            ULONG bytes = 0;

            status = ZwQueryInformationThread( hThread, ThreadBasicInformation, &info, sizeof( info ), &bytes );
            if (NT_SUCCESS( status ) && pExitStatus)
            {
                *pExitStatus = info.ExitStatus;
            }
            else if (!NT_SUCCESS( status ))
            {
                DbgPrint( "ZwQueryInformationThread failed with status 0x%X\n", status );
            }
        }
        else
            DbgPrint( "ZwWaitForSingleObject failed with status 0x%X\n", status );
    }
    else
        DbgPrint( "ZwCreateThreadEx failed with status 0x%X\n", status );

    if (hThread)
        ZwClose( hThread );

    return status;
}


//LaunchThread


VOID LaunchNewThread(PVOID funcAddr)
{
	BOOLEAN unprotec = FALSE;
	HANDLE curPID;
	PEPROCESS pProcess = NULL;
	NTSTATUS status = STATUS_SUCCESS;
	NTSTATUS threadStatus = STATUS_SUCCESS;
	UNICODE_STRING dllPath;
	PINJECT_BUFFER pUserBuf;
	
	curPID = PsGetCurrentProcessId();
    status = PsLookupProcessByProcessId( curPID, &pProcess );
    if (NT_SUCCESS( status ))
    {
		// If process is protected - temporarily disable protection	
		if (PsIsProtectedProcess( pProcess ))
		{
			//prot.pid = PsGetCurrentProcessId();
			//prot.enableState = FALSE;
			ChangeProcessProtection( curPID,FALSE  );
			unprotec = TRUE;
		}
		RtlInitUnicodeString( &dllPath, L"D:\\LoadDriverDebugProcess\\Debug\\SbieDll.dll"  );
		pUserBuf = GetInjectCode(funcAddr,&dllPath);
		status = ExecuteInNewThread( pUserBuf, NULL, THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER, TRUE, &threadStatus ); //TRUE para esperar //FALSE para no esperar
		// Injection failed
		if (!NT_SUCCESS( threadStatus ))
		{
			status = threadStatus;
			DbgPrint( "User thread failed with status - 0x%X\n", status );
		}
		
		if (unprotec)
		{
			//prot.enableState = TRUE;
			ChangeProcessProtection( PsGetCurrentProcessId(),FALSE );
		}
	}
}

typedef struct _INJECT_INFO
{
    HANDLE ProcessId;
    wchar_t DllName[1024];
}INJECT_INFO,*PINJECT_INFO;


typedef NTSTATUS (*PLDR_LOAD_DLL)(PWSTR,PULONG,PUNICODE_STRING,PVOID*);

typedef struct _KINJECT
{
    UNICODE_STRING DllName;
    wchar_t Buffer[1024];
    PLDR_LOAD_DLL LdrLoadDll;
	//PVOID LdrLoadDll;
    PVOID DllBase;
    ULONG Executed;
}KINJECT,*PKINJECT;

typedef enum _KAPC_ENVIRONMENT
{
    OriginalApcEnvironment,
    AttachedApcEnvironment,
    CurrentApcEnvironment,
    InsertApcEnvironment
}KAPC_ENVIRONMENT,*PKAPC_ENVIRONMENT;

VOID NTAPI KeInitializeApc(
    IN PRKAPC Apc,
    IN PRKTHREAD Thread,
    IN KAPC_ENVIRONMENT Environment,
    IN PKKERNEL_ROUTINE KernelRoutine,
    IN PKRUNDOWN_ROUTINE RundownRoutine,
    IN PKNORMAL_ROUTINE NormalRoutine,
    IN KPROCESSOR_MODE ProcessorMode,
    IN PVOID NormalContext
    );

BOOLEAN NTAPI KeInsertQueueApc(
    PRKAPC Apc,
    PVOID SystemArgument1,
    PVOID SystemArgument2,
    KPRIORITY Increment
    );	
	
void NTAPI KernelRoutine(PKAPC apc,PKNORMAL_ROUTINE* NormalRoutine,PVOID* NormalContext,PVOID* SystemArgument1,PVOID* SystemArgument2)
{
    ExFreePool(apc);
}


void NTAPI InjectDllApc(PVOID NormalContext,PVOID SystemArgument1,PVOID SystemArgument2)
{
    PKINJECT inject=(PKINJECT)NormalContext;
 
    inject->LdrLoadDll(NULL,NULL,&inject->DllName,&inject->DllBase);
    inject->Executed=TRUE;
}

BOOLEAN InjectDll(HANDLE ProcessId, PVOID LdrLoadDll)
//BOOLEAN InjectDll(HANDLE ProcessId,, PVOID LdrLoadDll)
{
    PEPROCESS Process;
    PETHREAD Thread;
 
    PKINJECT mem;
    ULONG size;
 
    PKAPC_STATE ApcState;
    PKAPC apc;
 
    PVOID buffer;
    SYSTEM_PROCESS_INFO spi;
	PSYSTEM_PROCESS_INFO pSpi;
	
    LARGE_INTEGER delay;
	
	
    //buffer=ExAllocatePool(NonPagedPool,1024*1024); // Allocate memory for the system information
	buffer = ExAllocatePoolWithTag(NonPagedPool,1024*1024,DRV_POOL_TAG);
    if(!buffer)
    {
        DbgPrint("Error: Unable to allocate memory for the process thread list.");
        return FALSE;
    }
 
    // Get the process thread list
 
    if(!NT_SUCCESS(ZwQuerySystemInformation(5,buffer,1024*1024,NULL)))
	
	//if(!NT_SUCCESS(ZwQuerySystemInformation(5,&spi,sizeof(SYSTEM_PROCESS_INFO),NULL)))
    {
        DbgPrint("Error: Unable to query process thread list.");
         
        ExFreePool(buffer);
        return FALSE;
    }
 
    //pSpi=(PSYSTEM_PROCESS_INFO)&spi;
	pSpi=(PSYSTEM_PROCESS_INFO)&buffer;
    // Find a target thread
	
    while(pSpi->NextEntryOffset)
    {
        if(pSpi->UniqueProcessId==ProcessId)
        {
			DbgPrint("Number of threads %d" ,pSpi->NumberOfThreads); 
            //DbgPrint("Target thread found. TID: %d",pSpi->Threads[0].ClientId.UniqueThread);
            break;
        }
 
        pSpi=(PSYSTEM_PROCESS_INFO)(&pSpi+pSpi->NextEntryOffset);
    }
 
	ExFreePool(buffer);//QUITAR
    // Reference the target process
 
    /*if(!NT_SUCCESS(PsLookupProcessByProcessId(InjectInfo->ProcessId,&Process)))
    {
        DbgPrint("Error: Unable to reference the target process.");
         
        ExFreePool(buffer);
        return FALSE;
    }
 
    DbgPrint("Process name: %s",PsGetProcessImageFileName(Process));
    DbgPrint("EPROCESS address: %#x",Process);
 
    // Reference the target thread
 
    if(!NT_SUCCESS(PsLookupThreadByThreadId(pSpi->Threads[0].ClientId.UniqueThread,&Thread)))
    {
        DbgPrint("Error: Unable to reference the target thread.");
        ObDereferenceObject(Process); // Dereference the target process
 
        ExFreePool(buffer); // Free the allocated memory
        return FALSE;
    }
 
    DbgPrint("ETHREAD address: %#x",Thread);
 
    ExFreePool(buffer); // Free the allocated memory
    KeAttachProcess(Process); // Attach to target process's address space
 
    mem=NULL;
    size=4096;
 
    // Allocate memory in the target process
 
    if(!NT_SUCCESS(ZwAllocateVirtualMemory(NtCurrentProcess(),(PVOID*)&mem,0,&size,MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE)))
    {
        DbgPrint("Error: Unable to allocate memory in the target process.");
        KeDetachProcess(); // Detach from target process's address space
 
        ObDereferenceObject(Process); // Dereference the target process
        ObDereferenceObject(Thread); // Dereference the target thread
 
        return FALSE;
    }
 
    DbgPrint("Memory allocated at %#x",mem);
 
    mem->LdrLoadDll=LdrLoadDll; // Write the address of LdrLoadDll to target process
    wcscpy(mem->Buffer,InjectInfo->DllName); // Write the DLL name to target process
 
    RtlInitUnicodeString(&mem->DllName,mem->Buffer); // Initialize the UNICODE_STRING structure
    ApcState=(PKAPC_STATE)((PUCHAR)Thread+ApcStateOffset); // Calculate the address of the ApcState structure
 
    ApcState->UserApcPending=TRUE; // Force the target thread to execute APC
 
    memcpy((PKINJECT)(mem+1),InjectDllApc,(ULONG)KernelRoutine-(ULONG)InjectDllApc); // Copy the APC code to target process
    DbgPrint("APC code address: %#x",(PKINJECT)(mem+1));
 
    //apc=(PKAPC)ExAllocatePool(NonPagedPool,sizeof(KAPC)); // Allocate the APC object
	apc=(PKAPC)ExAllocatePoolWithTag(NonPagedPool,sizeof(KAPC),DRV_POOL_TAG); // Allocate the APC object
    if(!apc)
    {
        DbgPrint("Error: Unable to allocate the APC object.");
        size=0;
 
        ZwFreeVirtualMemory(NtCurrentProcess(),(PVOID*)&mem,&size,MEM_RELEASE);  // Free the allocated memory
        KeDetachProcess(); // Detach from target process's address space
 
        ObDereferenceObject(Process); // Dereference the target process
        ObDereferenceObject(Thread); // Dereference the target thread
 
        return FALSE;
    }
 
    KeInitializeApc(apc,Thread,OriginalApcEnvironment,KernelRoutine,NULL,(PKNORMAL_ROUTINE)((PKINJECT)mem+1),UserMode,mem); // Initialize the APC
    DbgPrint("Inserting APC to target thread");
 
    // Insert the APC to the target thread
 
    if(!KeInsertQueueApc(apc,NULL,NULL,IO_NO_INCREMENT))
    {
        DbgPrint("Error: Unable to insert APC to target thread.");
        size=0;
         
        ZwFreeVirtualMemory(NtCurrentProcess(),(PVOID*)&mem,&size,MEM_RELEASE); // Free the allocated memory
        KeDetachProcess(); // Detach from target process's address space
 
        ObDereferenceObject(Process); // Dereference the target process
        ObDereferenceObject(Thread); // Dereference the target thread
 
        ExFreePool(apc); // Free the APC object
        return FALSE;
    }
 
    delay.QuadPart=-100*10000;
 
    while(!mem->Executed)
    {
        KeDelayExecutionThread(KernelMode,FALSE,&delay); // Wait for the injection to complete
    }
 
    if(!mem->DllBase)
    {
        DbgPrint("Error: Unable to inject DLL into target process.");
        size=0;
 
        ZwFreeVirtualMemory(NtCurrentProcess(),(PVOID*)&mem,&size,MEM_RELEASE);
        KeDetachProcess();
 
        ObDereferenceObject(Process);
        ObDereferenceObject(Thread);
         
        return FALSE;
    }
 
    DbgPrint("DLL injected at %#x",mem->DllBase);
    size=0;
 
    ZwFreeVirtualMemory(NtCurrentProcess(),(PVOID*)&mem,&size,MEM_RELEASE); // Free the allocated memory
    KeDetachProcess(); // Detach from target process's address space
 
    ObDereferenceObject(Process); // Dereference the target process
    ObDereferenceObject(Thread);  // Dereference the target thread
 */
    return TRUE;
}
 

//
//Executable mapping function callback
//
VOID DllMapCallback (IN PUNICODE_STRING FullImageName, IN HANDLE ProcessId, IN PIMAGE_INFO ImageInfo)
{
	UNICODE_STRING  ustrNtdll, upperFullName;
	NTSTATUS ntS,ret;
	int compare,stringsDifference;
	PVOID pAddr = NULL;
	PEPROCESS ep;
	KAPC_STATE ka_state;
	INJECT_INFO pInject;
	
	PDEVICE_EXTENSION extension;
	
	if (ProcessId ==0) //Cuando el Pid es 0 se esta mapeando un driver
	{
		return;
	}
	
	ntS = RtlUpcaseUnicodeString(&upperFullName,FullImageName,TRUE);
	if (ntS != STATUS_SUCCESS)
	{
		return;
	}
	
	RtlInitUnicodeString( &ustrNtdll, L"KERNEL32.DLL" );
	//RtlInitUnicodeString( &ustrNtdll, L"NTDLL.DLL" );
	//DbgPrint("loaded %wZ into Process: %d, FullImageLength:%d ntdllLength:%d",FullImageName,ProcessId,FullImageName->Length,ustrNtdll.Length );
	//DbgPrint("upper %wZ ",&upperFullName);
	
	stringsDifference = (upperFullName.Length - ustrNtdll.Length) /2;
	
	
	compare = RtlCompareMemory(upperFullName.Buffer+stringsDifference, ustrNtdll.Buffer, ustrNtdll.Length);
	
	if (compare == ustrNtdll.Length)
	{
		DbgPrint("loaded %wZ into Process: %d, FullImageLength:%d ntdllLength:%d",FullImageName,ProcessId,FullImageName->Length,ustrNtdll.Length );
		DbgPrint ("NTDLL found Process %d, ", PsGetCurrentProcessId());
		//obtener base dll
		pAddr = GetModuleExportAddress(ImageInfo->ImageBase,"NtCreateThreadEx");
		if (pAddr != NULL)
		{
			DbgPrint("Found funcion NtCreateThreadEx address %d indexCall %d", pAddr,*(INT*)(((INT)pAddr)+1)); 
		}
		//pAddr = GetModuleExportAddress(ImageInfo->ImageBase,"LdrLoadDll");
		pAddr = GetModuleExportAddress(ImageInfo->ImageBase,"LoadLibraryA");
		if (pAddr != NULL)
		{
			DbgPrint("Found function, address %d", pAddr);
			
			EncolarRespuesta(ProcessId,pAddr); //Guardamos el PID en una Queue para ir sacandolos segun los solicitemos
			CancelPendingIRP(); //Cancelar alguna IRP pendiente para lanzar el PID a userSpace
			

			// Assign extension variable
			/*extension = g_pDeviceObject->DeviceExtension;

			// Assign current values into device extension.  
			// User-mode apps will pick it up using DeviceIoControl calls.
			extension->hProcessId         = ProcessId;
			extension->LoadLibraryAddress = pAddr;
			
			// Pulse the event so any user-mode apps listening will know something
			// interesting has happened.  Sadly, user-mode apps can't reset a KM
			// event, which is why we're pulsing it here...
			KeSetEvent(extension->ProcessEvent, 0, FALSE);
			KeClearEvent(extension->ProcessEvent);
			*/
			/*pInject.ProcessId = ProcessId;
			wcscpy(pInject.DllName,L"D:\\LoadDriverDebugProcess\\Debug\\SbieDll.dll");
			DbgPrint ("Injecting %ws",pInject.DllName);*/
			//InjectDll(ProcessId, pAddr);
			/*ret=PsLookupProcessByProcessId((HANDLE)ProcessId,&ep);

			if(!NT_SUCCESS(ret)) {

				DbgPrint("get_session_id PsLookupProcessByProcessId failed",ret);

				return;

			}

			KeStackAttachProcess(ep,&ka_state);
		

			
			//Crear nuevo Thread y lanzar LoadDll con el path de la nueva dll
			LaunchNewThread(pAddr);
			KeUnstackDetachProcess(&ka_state);*/
		}
	}
	else
	{
		//DbgPrint ("No NTDLL compare %d difference %d  Orig: %ws Mayusc: %ws NTDLL %ws ",compare ,stringsDifference, upperFullName.Buffer, upperFullName.Buffer+stringsDifference,ustrNtdll.Buffer  );
	}
	
	RtlFreeUnicodeString(&upperFullName);
	
	return;
}


//
// Process function callback
//
VOID ProcessCallback(IN HANDLE  hParentId, 	IN HANDLE  hProcessId, 	IN BOOLEAN bCreate	)
{   
	PEPROCESS ep;
	NTSTATUS ret;
	KAPC_STATE ka_state;
	PPEB peb;
	int isDebug;	
	PVOID pNtdll,LdrLoadDll,systemBuffer;
//	BOOLEAN isWow64;
	UNICODE_STRING ustrPath, ustrNtdll;
	//int * rawNProcessors;
	
	peb=NULL;
	ep=NULL;	
	pNtdll = NULL;
	LdrLoadDll = NULL;
	systemBuffer = NULL;
	
	if (!bCreate)
	{
		return;
	}
	
	
    DbgPrint("process created hProcess %d ",hProcessId);    	
	ret=PsLookupProcessByProcessId((HANDLE)hProcessId,&ep);

	if(!NT_SUCCESS(ret)) {

		DbgPrint("get_session_id PsLookupProcessByProcessId failed",ret);

		return;

	}
	DbgPrint( PsGetProcessImageFileName (ep));	
	
	//isWow64 = (PsGetProcessWow64Process( ep ) != NULL) ? TRUE : FALSE;
	
	peb=PsGetProcessPeb(ep);
    
	if (peb)
	{
		DbgPrint("get_session_id peb %d\n",peb);

		KeStackAttachProcess(ep,&ka_state);
		isDebug=(int)peb->BeingDebugged;
		DbgPrint("Being debuged %d\n",(int)isDebug);
		DbgPrint("RAW N Process %d\n",(int) peb->NumberOfProcessors);
		if (!isDebug){
			peb->BeingDebugged =1;
			peb->NumberOfProcessors = 1;
		}
		//rawNProcessors = (int*) peb+0x64;
		DbgPrint("FINAL RAW N Process %d\n",(int) peb->NumberOfProcessors);
		DbgPrint("FINAL Being debuged %d\n",(int)peb->BeingDebugged);

		KeUnstackDetachProcess(&ka_state);

     }

     

     // cleanup

	ObDereferenceObject(ep);
}



NTSTATUS DispatchIoctl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS              ntStatus = STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION    irpStack  = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION     extension = DeviceObject->DeviceExtension;
    //PCALLBACK_INFO        pCallbackInfo;
    //DbgPrint("Call to DispatchIoctl %d" ,irpStack->Parameters.DeviceIoControl.IoControlCode);
	//
    // These IOCTL handlers get the current data out of the device
    // extension structure.  
	//
    switch(irpStack->Parameters.DeviceIoControl.IoControlCode)
    {
        case IOCTL_NTPROCDRV_LOADDLL:
            //DbgPrint("Recibed data request");
            if(irpStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(CALLBACK_INFO))
            {
              /*  pCallbackInfo = Irp->AssociatedIrp.SystemBuffer;
              
                pCallbackInfo->hProcessId 			= extension->hProcessId;
                pCallbackInfo->loadLibraryAddress   = extension->LoadLibraryAddress;*/
    
                ntStatus = STATUS_SUCCESS;
            }
			
            break;

        default:
            //DbgPrint("Recibed other requests");
            break;
    }

    Irp->IoStatus.Status = ntStatus;
   
    // Set number of bytes to copy back to user-mode
    if(ntStatus == STATUS_SUCCESS)
        Irp->IoStatus.Information = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    else
        Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return ntStatus;
}


//
// Driver unload routine
//
void UnloadDriver(IN PDRIVER_OBJECT DriverObject)
{
    UNICODE_STRING  uszDeviceString;
	NTSTATUS        ntStatus;

    // restore the call back routine, thus givinig chance to the 
	// user mode application to unload dynamically the driver
	DbgPrint("Unload driver");
    ntStatus = PsSetCreateProcessNotifyRoutine(ProcessCallback, TRUE);
	ntStatus = PsRemoveLoadImageNotifyRoutine(DllMapCallback);
    IoDeleteDevice(DriverObject->DeviceObject);

    RtlInitUnicodeString(&uszDeviceString, L"\\DosDevices\\ProcDebugger");
    IoDeleteSymbolicLink(&uszDeviceString);
}
