// ConsoleTestDebug.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"


#include <iphlpapi.h>
#include <Shlwapi.h>
#include <Winnetwk.h>



void CallIsDebuggerPresent()
{
	if (IsDebuggerPresent())
	{
		printf("Debuggeando!!!!\n");
	}
	else
	{
		printf("No debuggado.....\n");
	}
	/*char * userNames [] = {
		"VIRUS",
		"MALWARE",
		"SANDBOX",
		NULL
	};
	for (int i = 0;i<(sizeof(userNames)/4)-1;i++)
	{
		printf ("size of %d %d\n",i, strlen (userNames[i]));
	}
	*/
}
//#ifdef DEBUG
void ShowUserName()
{
	TCHAR  userName[200];
	DWORD luser= 200;
	/*char  userName[200];
	DWORD luser= 200;*/
	luser +=1;
	luser -=1;
	GetUserName(userName, &luser);

#ifdef UNICODE
	printf ("GetUserName %S\n",  userName);
#else
	printf ("GetUserName %s\n",  userName);
#endif
}
//#endif

void ShowProgramHandle()
{
	TCHAR path[500];
	DWORD pathsize = sizeof(path);
	GetModuleFileName(NULL, path, pathsize);
#ifdef UNICODE
	printf ("GetModuleFileNameW %S\n", path);
#else
	printf ("GetModuleFileName %s\n", path);
#endif
	/*GetModuleFileName(NULL, pathAux, pathsize);
	PathRemoveFileSpec(path);
	printf ("Remove fileName %S\n",path);
	PathStripPath(pathAux);
	printf ("FileName %S\n",path);
	PathAppend(path,"VIRUS");
	printf ("PathAppend %S\n",path);
	PathAppend(path,pathAux);
	printf ("Final path %S\n",path);*/

}
void ShowDiskFreeSpace()
{
	ULARGE_INTEGER freeBytesAvailable;
	ULARGE_INTEGER total_bytes;
	ULARGE_INTEGER totalNumberOfFreeBytes;
#ifdef UNICODE	
	TCHAR * rootPath = L"C:\\Windows";
#else
	TCHAR* rootPath = "C:\\Windows";
#endif

	if (GetDiskFreeSpaceEx(rootPath, &freeBytesAvailable, &total_bytes, &totalNumberOfFreeBytes))
	{
		printf("GetDiskFreeSpaceEx freeByAva: %llu, total Bytes: %llu, totalNumberOfFreeBytes %llu\n",freeBytesAvailable.QuadPart, total_bytes.QuadPart, totalNumberOfFreeBytes.QuadPart);
	}
	else
	{
		printf("Error GetDiskFreeSpaceEx");
	}
	
	DWORD sectoresPerCluster, bytesPerSector, numberOfFreeClusters, totalNumberOfClusters;

	if (GetDiskFreeSpace(rootPath,&sectoresPerCluster,&bytesPerSector,&numberOfFreeClusters,&totalNumberOfClusters))
	{
		printf("GetDiskFreeSpace seCxCulst: %d, bytesXSect: %d, freeClusters %d, totalClusters %d\n",sectoresPerCluster,bytesPerSector,numberOfFreeClusters,totalNumberOfClusters);
	}
	else
	{
		printf("Error GetDiskFreeSpace");
	}

}

void ShowRAMMemory()
{
	MEMORYSTATUS mem;
	mem.dwLength = sizeof(mem);

	GlobalMemoryStatus(&mem);
	printf ("GetGlobalMemory MemoryLoad: %d, TotalPh: %d, AvPh: %d \n",mem.dwMemoryLoad, mem.dwTotalPhys, mem.dwAvailPhys);
	printf ("                TotalPageFile: %lu, AvPageFile: %lu\n",mem.dwTotalPageFile, mem.dwAvailPageFile);
	printf ("                TotalVirtual:  %d, AvVirtual:  %d\n",mem.dwTotalVirtual, mem.dwAvailVirtual);

	MEMORYSTATUSEX mem2;
	mem2.dwLength = sizeof(mem2);
	GlobalMemoryStatusEx(&mem2);
	printf ("GetGlobalMemoryEx MemoryLoad: %d, TotalPh: %d, AvPh: ",mem2.dwMemoryLoad, mem2.ullTotalPhys);
	printf ("%d\n",mem2.ullAvailPhys);
}

void ShowProcesorNumber()
{
	SYSTEM_INFO siSysInfo;
	GetSystemInfo(&siSysInfo);
	printf("GetSystemInfo, numberProcesor: %d ActiveMask: %d\n", siSysInfo.dwNumberOfProcessors, siSysInfo.dwActiveProcessorMask );
}

void ShowGetTickCount()
{
	DWORD t = GetTickCount();
	printf ("GetTickCount : %lu\n ",t);
}


static int check_hook_m1(DWORD * dwAddress) {
	BYTE *b = (BYTE *)dwAddress;
	return (*b == 0x8b) && (*(b+1) == 0xff) ? FALSE : TRUE;
}

void ShowCheckHooks()
{
	printf("Address DeleteFileW: %lu, ShellExecuteExW: %lu, CreateProcessA: %lu\n", (DWORD *)DeleteFileW,(DWORD *)ShellExecuteExW,(DWORD *)CreateProcessA ) ;
	printf("Check   DeleteFileW: %d,  ShellExecuteExW: %d,  CreateProcessA: %d\n",	check_hook_m1((DWORD *)DeleteFileW),
																					check_hook_m1((DWORD *)ShellExecuteExW),
																					check_hook_m1((DWORD *)CreateProcessA) );
}

int ShowMACaddrs(char * name) {
	unsigned long alist_size = 0, ret;

	ret = GetAdaptersAddresses(AF_UNSPEC,0,0,0,&alist_size);
	if(ret==ERROR_BUFFER_OVERFLOW) {
		IP_ADAPTER_ADDRESSES* palist = (IP_ADAPTER_ADDRESSES*)LocalAlloc(LMEM_ZEROINIT,alist_size);
		if(palist) {
			GetAdaptersAddresses(AF_UNSPEC,0,0,palist,&alist_size);
			char mac[6]={0};
			while (palist){
				if (palist->PhysicalAddressLength==0x6){
					printf("  %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n",
						palist->PhysicalAddress[0],
						palist->PhysicalAddress[1],
						palist->PhysicalAddress[2],
						palist->PhysicalAddress[3],
						palist->PhysicalAddress[4],
						palist->PhysicalAddress[5]);
				}
				palist = palist->Next;
			}
			LocalFree(palist);
		}
	}
	return FALSE;
}
void ShowPseudoDevices()
{
	HANDLE h;
	const int count = 6;


	TCHAR* strs[count];
	int res = FALSE, i = 0;
	
#ifdef UNICODE
	strs[0] = L"\\\\.\\HGFS";
	strs[1] = L"\\\\.\\vmci";
	strs[2] = L"\\\\.\\VBoxMiniRdrDN";
	strs[3] = L"\\\\.\\pipe\\VBoxMiniRdDN";
	strs[4] = L"\\\\.\\VBoxTrayIPC";
	strs[5] = L"\\\\.\\pipe\\VBoxTrayIPC";
#else
	strs[0] = "\\\\.\\HGFS";
	strs[1] = "\\\\.\\vmci";
	strs[2] = "\\\\.\\VBoxMiniRdrDN";
	strs[3] = "\\\\.\\pipe\\VBoxMiniRdDN";
	strs[4] = "\\\\.\\VBoxTrayIPC";
	strs[5] = "\\\\.\\pipe\\VBoxTrayIPC";
#endif

	for (i=0; i < count; i++) {
		h = CreateFile(strs[i], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (h != INVALID_HANDLE_VALUE) {
#ifdef UNICODE
			printf("VMWare o VBOX traced using device %S\n", strs[i]);
#else
			printf("VMWare o VBOX traced using device %s\n", strs[i]);
#endif
			
		}
		else
		{
#ifdef UNICODE
			printf("VMWare o VBOX NOT traced using device %S\n", strs[i]);
#else
			printf("VMWare o VBOX NOT traced using device %s\n", strs[i]);
#endif
		}
	}


}


void PrintIsNativeVhdBoot()
{
	typedef BOOL (WINAPI * IsNativeVhdBoot) (BOOL *);

	BOOL isnative = FALSE;
	IsNativeVhdBoot fnnative = (IsNativeVhdBoot) GetProcAddress(
			GetModuleHandleA("kernel32"), "IsNativeVhdBoot");
	/* IsNativeVhdBoot always returns 1 on query success */
	if (fnnative)
	{
		fnnative(&isnative);
		if (isnative)
		{
			printf("IS NATIVE VHD BOOT\n");
		}
		else
		{
			printf("no native VHD BOOT\n");
		}
	}
	else
	{
		printf("No function IsNativeVhdBoot available\n");
	}
	
}

void PrintGetProviderName() {
	unsigned long pnsize = 0x1000;
	TCHAR provider[0x1000];
	/* a0rtega : any reason for this to be in the heap :?, changed to stack */
	//char * provider = (char *)LocalAlloc(LMEM_ZEROINIT, pnsize);

	int retv = WNetGetProviderName(WNNC_NET_RDR2SAMPLE, provider, &pnsize);
	if (retv == NO_ERROR) 
	{
#ifdef UNICODE
	printf ("Providers name %S\n",provider);
#else
	printf ("Providers name %s\n",provider);
#endif

		
	}
	else
	{
		printf ("Error GetProviderName\n");
	}
}

int _tmain(int argc, _TCHAR* argv[])
{
	for (int i = 0; i< 10; i++)
	{
		printf ("-------- Debugging -----------------\n");
		CallIsDebuggerPresent();
		printf ("\n-------- UserName  -----------------\n");
		ShowUserName();
#ifdef COSACOSAS
		TCHAR  userName[200];
		DWORD luser= 200;
		/*char  userName[200];
		DWORD luser= 200;*/
		luser +=1;
		luser -=1;
		GetUserName(userName, &luser);

		#ifdef UNICODE
			printf ("GetUserName %S\n",  userName);
		#else
			printf ("GetUserName %s\n",  userName);
		#endif
#endif
		printf ("\n-------- ProgramHandle --------------\n");
		ShowProgramHandle();
		printf ("\n-------- Free Disk Space-------------\n");
		ShowDiskFreeSpace();
		printf ("\n-------- RAM Memory -----------------\n");
		ShowRAMMemory();
		printf ("\n-------- Number of Processors -------\n");
		ShowProcesorNumber();
		printf ("\n-------- Tick Counts ----------------\n");
		ShowGetTickCount();
		printf ("\n-------- Check Hooks ----------------\n");
		ShowCheckHooks();
		printf ("\n-------- MAC Addrs ------------------\n");
		ShowMACaddrs("");
		printf ("\n-------- PseudoDevices --------------\n");
		ShowPseudoDevices();
		printf ("\n-------- NativeVhdBoot --------------\n");
		PrintIsNativeVhdBoot();
		printf ("\n-------- GetProviderName ------------\n");
		PrintGetProviderName();
		printf("----------------------------------------\n\n");
		Sleep(2000);
	}
	return 0;
}

